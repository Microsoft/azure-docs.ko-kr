---
title: 장애 조치 (Failover) 및 패치-Redis 용 Azure 캐시
description: Redis 용 Azure Cache의 장애 조치 (failover), 패치 및 업데이트 프로세스에 대해 알아봅니다.
author: asasine
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 6ff33bd594181aabc4fd7d55ce33f780a0d06086
ms.sourcegitcommit: 5a8c65d7420daee9667660d560be9d77fa93e9c9
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/15/2019
ms.locfileid: "74122196"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Redis 용 Azure 캐시에 대한 장애 조치 (Failover) 및 패치

복원 력 하 고 성공적인 클라이언트 응용 프로그램을 빌드하려면 Redis 용 Azure 캐시 서비스의 컨텍스트에서 장애 조치 (failover)를 이해 하는 것이 중요 합니다. 장애 조치 (failover)는 계획 된 관리 작업의 일부일 수도 있고, 계획 되지 않은 하드웨어 또는 네트워크 오류로 인해 발생할 수도 있습니다. 일반적으로 캐시 장애 조치 (failover)는 관리 서비스에서 Azure Cache for Redis 이진 파일을 패치 하는 경우에 제공 됩니다. 이 문서에서는 장애 조치 (failover)의 정의, 패치 중에 발생 하는 방법 및 복원 력 클라이언트 응용 프로그램을 빌드하는 방법을 설명 합니다.

## <a name="what-is-a-failover"></a>장애 조치 (failover) 란?

Redis 용 Azure Cache에 대한 장애 조치 (failover) 개요부터 살펴보겠습니다.

### <a name="a-quick-summary-of-cache-architecture"></a>캐시 아키텍처에 대한 빠른 요약

캐시는 별도의 개인 IP 주소를 사용 하 여 여러 가상 머신으로 구성 됩니다. 노드 라고도 하는 각 가상 머신은 단일 가상 IP 주소를 사용 하 여 공유 부하 분산 장치에 연결 됩니다. 각 노드는 Redis 서버 프로세스를 실행 하며 호스트 이름과 Redis 포트를 통해 액세스할 수 있습니다. 각 노드는 마스터 또는 복제본 노드로 간주 됩니다. 클라이언트 응용 프로그램에서 캐시에 연결 하는 경우 해당 트래픽은이 부하 분산 장치를 통해 이동 하 고 마스터 노드로 자동 라우팅됩니다.

기본 캐시에서 단일 노드는 항상 마스터입니다. 표준 또는 프리미엄 캐시에는 두 개의 노드가 있습니다. 하나는 마스터로 선택 하 고 다른 하나는 복제본입니다. Standard 및 Premium 캐시에는 여러 노드가 있으므로 한 노드는 사용할 수 없게 되 고 다른 노드는 계속 해 서 요청을 처리 합니다. 클러스터 된 캐시는 각각 고유한 마스터 및 복제본 노드가 있는 많은 분할로 구성 됩니다. 하나의 분할 된 데이터베이스가 사용 가능한 상태를 유지 하는 동안 중단 될 수 있습니다.

> [!NOTE]
> 기본 캐시는 여러 노드를 포함 하지 않으며 가용성에 대한 SLA (서비스 수준 계약)를 제공 하지 않습니다. 기본 캐시는 개발 및 테스트 목적 으로만 사용 하는 것이 좋습니다. 다중 노드 배포에 표준 또는 프리미엄 캐시를 사용 하 여 가용성을 높입니다.

### <a name="explanation-of-a-failover"></a>장애 조치에 대한 설명

장애 조치 (failover)는 복제본 노드가 마스터 노드가 되도록 수준을 올리고 이전 마스터 노드가 기존 연결을 닫는 경우에 발생 합니다. 마스터 노드가 다시 백업 된 후에는 역할의 변경을 제공 하 고 복제본이 되도록 수준을 내립니다. 그런 다음 새 마스터에 연결 하 고 데이터를 동기화 합니다. 장애 조치 (failover)가 계획 되거나 계획 되지 않을 수 있습니다.

*계획 된 장애 조치 (failover)* 는 Redis 패치 또는 OS 업그레이드와 같은 시스템 업데이트 및 크기 조정 및 다시 부팅 등의 관리 작업을 수행 하는 동안 발생 합니다. 노드는 업데이트에 대한 사전 알림을 받기 때문에 역할을 협조적으로 교체 하 고 변경의 부하 분산 장치를 신속 하 게 업데이트할 수 있습니다. 계획 된 장애 조치 (failover)는 일반적으로 1 초 이내에 완료 됩니다.

계획 되지 않은 *장애 조치 (failover)* 는 하드웨어 오류, 네트워크 오류 또는 마스터 노드에 대한 예기치 않은 중단으로 인해 발생할 수 있습니다. 복제본 노드는 자신을 master로 승격 하지만 프로세스는 더 오래 걸립니다. 복제본 노드에서 장애 조치 (failover) 프로세스를 시작 하려면 먼저 해당 마스터 노드를 사용할 수 없는 것으로 검색 해야 합니다. 또한 불필요 한 장애 조치 (failover)를 방지 하기 위해 복제 노드에서이 계획 되지 않은 오류가 일시적 또는 로컬이 아닌지 확인 해야 합니다. 이러한 검색 지연은 일반적으로 10 ~ 15 초 이내에 계획 되지 않은 장애 조치 (failover)가 완료 됨을 의미 합니다.

## <a name="how-does-patching-occur"></a>패치가 어떻게 발생 하나요?

Redis 용 Azure Cache 서비스는 최신 플랫폼 기능 및 픽스를 사용 하 여 캐시를 정기적으로 업데이트 합니다. 캐시를 패치 하기 위해 서비스는 다음 단계를 따릅니다.

1. 관리 서비스는 패치할 노드 하나를 선택 합니다.
1. 선택한 노드가 마스터 노드인 경우 해당 복제본 노드가 협조적으로 승격 됩니다. 이 프로 모션은 계획 된 장애 조치 (failover)로 간주 됩니다.
1. 새 변경 내용을 적용 하 고 복제본 노드로 다시 이동 하도록 선택한 노드가 다시 부팅 됩니다.
1. 복제본 노드는 마스터 노드에 연결 하 고 데이터를 동기화 합니다.
1. 데이터 동기화가 완료 되 면 나머지 노드에 대해 패치 프로세스가 반복 됩니다.

패치는 계획 된 장애 조치 (failover) 이므로 복제본 노드는 마스터 역할을 하 고 요청 및 새 연결에 대한 서비스를 시작 하도록 신속 하 게 승격 됩니다. 기본 캐시에는 복제본 노드가 없으며 업데이트가 완료 될 때까지 사용할 수 없습니다. 클러스터형 캐시의 각 분할은 개별적으로 패치 되며 다른 분할 영역에 대한 연결은 닫히지 않습니다.

> [!IMPORTANT]
> 노드는 데이터 손실을 방지 하기 위해 한 번에 하나씩 패치가 적용 됩니다. 기본 캐시는 데이터 손실을 초래할 수 있습니다. 클러스터 된 캐시는 한 번에 하나의 분할 된에 패치가 적용 됩니다.

동일한 리소스 그룹 및 지역에 있는 여러 캐시도 한 번에 하나씩 패치 됩니다.  다른 리소스 그룹 또는 다른 지역에 있는 캐시는 동시에 패치할 수 있습니다.

전체 데이터 동기화는 프로세스를 반복 하기 전에 발생 하므로 표준 또는 프리미엄 캐시를 사용 하는 경우 데이터 손실이 발생할 가능성은 거의 없습니다. 데이터를 [내보내고](cache-how-to-import-export-data.md#export) [지 속성](cache-how-to-premium-persistence.md)을 설정 하 여 데이터 손실을 방지할 수 있습니다.

## <a name="additional-cache-load"></a>추가 캐시 로드

장애 조치 (failover)가 발생할 때마다 표준 및 프리미엄 캐시는 한 노드에서 다른 노드로 데이터를 복제 해야 합니다. 이 복제로 인해 서버 메모리와 CPU 모두에서 몇 가지 부하가 증가 합니다. 캐시 인스턴스가 이미 과도 하 게 로드 된 경우 클라이언트 응용 프로그램에서 대기 시간이 길어질 수 있습니다. 극단적인 경우에는 클라이언트 응용 프로그램이 시간 초과 예외를 받을 수 있습니다. 이 추가 로드의 영향을 완화 하기 위해 캐시의 `maxmemory-reserved` 설정을 [구성](cache-configure.md#memory-policies) 합니다.

## <a name="how-does-a-failover-affect-my-client-application"></a>장애 조치 (failover)는 클라이언트 응용 프로그램에 어떤 영향을 미칩니까?

클라이언트 응용 프로그램에서 표시 되는 오류 수는 장애 조치 (failover) 시 해당 연결에서 보류 중인 작업의 수에 따라 달라 집니다. 연결을 닫은 노드를 통해 라우팅되는 모든 연결에는 오류가 표시 됩니다. 제한 시간 예외, 연결 예외 또는 소켓 예외를 포함 하 여 연결이 끊어질 때 많은 클라이언트 라이브러리에서 다양 한 유형의 오류를 throw 할 수 있습니다. 예외의 수와 형식은 캐시에서 해당 연결을 닫을 때 코드 경로에서 요청 하는 위치에 따라 달라 집니다. 예를 들어 요청을 전송 하지만 장애 조치 (failover)가 발생할 때 응답을 받지 못한 작업은 시간 초과 예외가 발생할 수 있습니다. 닫힌 연결 개체에 대한 새 요청은 다시 연결이 성공적으로 발생할 때까지 연결 예외를 수신 합니다.

이러한 작업을 수행 하도록 구성 된 경우 대부분의 클라이언트 라이브러리는 캐시에 다시 연결 하려고 합니다. 그러나 예측할 수 없는 버그는 때때로 라이브러리 개체를 복구할 수 없는 상태로 저장할 수 있습니다. 오류가 미리 구성 된 시간 보다 오래 지속 되는 경우 연결 개체를 다시 만들어야 합니다. Microsoft.NET 및 기타 개체 지향 언어에서는 [Lazy\<t\> 패턴을](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)사용 하 여 응용 프로그램을 다시 시작 하지 않고 연결을 다시 만들 수 있습니다.

### <a name="how-do-i-make-my-application-resilient"></a>응용 프로그램을 복원 력을 어떻게 할까요? 하 고 있습니까?

장애 조치 (failover)를 완전히 방지할 수 없기 때문에, 연결 중단 및 실패 한 요청에 대한 복원을 위해 클라이언트 응용 프로그램을 작성 합니다 대부분의 클라이언트 라이브러리는 캐시 엔드포인트에 자동으로 다시 연결 되지만 일부는 실패 한 요청을 다시 시도 합니다. 응용 프로그램 시나리오에 따라 백오프와 함께 재시도 논리를 사용 하는 것이 적합할 수 있습니다.

클라이언트 응용 프로그램의 복원 력을 테스트 하려면 [다시 부팅](cache-administration.md#reboot) 을 연결 중단을 위한 수동 트리거로 사용 합니다. 또한 캐시에서 [업데이트를 예약](cache-administration.md#schedule-updates) 하는 것이 좋습니다. 지정 된 주간 windows에서 Redis 런타임 패치를 적용 하도록 관리 서비스에 지시 합니다. 이러한 창은 잠재적 인시던트를 방지 하기 위해 일반적으로 클라이언트 응용 프로그램 트래픽이 적은 경우에 발생 합니다.

### <a name="client-network-configuration-changes"></a>클라이언트 네트워크 구성 변경

특정 클라이언트 쪽 네트워크 구성 변경 내용은 "사용 가능한 연결 없음" 오류를 트리거할 수 있습니다. 이러한 변경 내용에는 다음이 포함 될 수 있습니다.

- 스테이징 및 프로덕션 슬롯 간에 클라이언트 응용 프로그램의 가상 IP 주소를 교환 합니다.
- 응용 프로그램의 인스턴스 크기 또는 수를 확장 합니다.

이러한 변경으로 인해 1 분 미만으로 지속 되는 연결 문제가 발생할 수 있습니다. 클라이언트 응용 프로그램은 Azure Cache for Redis 서비스 외에도 다른 외부 네트워크 리소스에 대한 연결을 손실할 수 있습니다.

## <a name="next-steps"></a>다음 단계

- 캐시에 대한 [업데이트를 예약](cache-administration.md#schedule-updates) 합니다.
- [다시 부팅](cache-administration.md#reboot)을 사용 하 여 응용 프로그램 복원 력을 테스트 합니다.
- 메모리 예약 및 정책을 [구성](cache-configure.md#memory-policies) 합니다.
