---
title: Azure SignalR Service에 대한 성능 가이드
description: Azure SignalR 서비스의 성능 및 벤치 마크에 대한 개요입니다. 용량을 계획할 때 고려해 야 할 주요 메트릭입니다.
author: sffamily
ms.service: signalr
ms.topic: conceptual
ms.date: 11/13/2019
ms.author: zhshang
ms.openlocfilehash: 68cad32be177fa20794399157fca89e87c2f8f59
ms.sourcegitcommit: 28688c6ec606ddb7ae97f4d0ac0ec8e0cd622889
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2019
ms.locfileid: "74157676"
---
# <a name="performance-guide-for-azure-signalr-service"></a>Azure SignalR Service에 대한 성능 가이드

Azure SignalR Service를 사용 하는 주요 이점 중 하나는 SignalR 응용 프로그램 크기 조정의 용이성입니다. 대규모 시나리오에서는 성능이 중요 한 요인입니다. 

이 가이드에서는 SignalR 응용 프로그램 성능에 영향을 주는 요인을 소개 합니다. 다양 한 사용 사례 시나리오에서 일반적인 성능을 설명 합니다. 마지막으로 성능 보고서를 생성 하는 데 사용할 수 있는 환경 및 도구를 소개 합니다.

## <a name="term-definitions"></a>용어 정의

*인바운드*: Azure SignalR Service에 대한 들어오는 메시지입니다.

*아웃 바운드*: Azure SignalR 서비스에서 보내는 메시지입니다.

*대역폭*: 1 초 안에 있는 모든 메시지의 총 크기입니다.

*기본 모드*: Azure SignalR 서비스 인스턴스를 만들 때 기본 작업 모드입니다. Azure SignalR 서비스는 클라이언트 연결을 허용 하기 전에 앱 서버에서 연결을 설정 하는 것으로 예상 합니다.

*서버*를 사용 하지 않는 모드: Azure SignalR Service가 클라이언트 연결만 수락 하는 모드입니다. 서버 연결이 허용 되지 않습니다.

## <a name="overview"></a>개요

Azure SignalR 서비스는 다양 한 성능 용량에 대해 7 개의 표준 계층을 정의 합니다. 이 가이드는 다음 질문에 대한 답을 제시 합니다.

-   각 계층에 대한 일반적인 Azure SignalR 서비스 성능은 무엇 인가요?

-   Azure SignalR Service는 메시지 처리량을 위한 요구 사항을 충족 하나요 (예: 초당 10만 메시지 전송)?

-   특정 시나리오의 경우 적합 한 계층은 무엇 인가요? 또는 적절 한 계층을 선택 하려면 어떻게 해야 하나요?

-   내게 적합 한 앱 서버 (VM 크기)의 종류는 무엇 인가요? 얼마나 많은 항목을 배포 해야 하나요?

이러한 질문에 대답 하기 위해이 가이드는 먼저 성능에 영향을 주는 요소에 대한 개략적인 설명을 제공 합니다. 그런 다음 일반적인 사용 사례에 대한 모든 계층에 대한 최대 인바운드 및 아웃 바운드 메시지를 보여 줍니다. **에코**, **브로드캐스트**, **그룹에 보내기**및 **연결에 보내기** (피어 투 피어 채팅)

이 가이드에서는 모든 시나리오 (다른 사용 사례, 메시지 크기, 메시지 전송 패턴 등)를 다룰 수 없습니다. 하지만 다음과 같은 몇 가지 방법을 제공 합니다.

- 인바운드 또는 아웃 바운드 메시지에 대한 대략적인 요구 사항을 평가 합니다.
- 성능 테이블을 확인 하 여 적절 한 계층을 찾습니다.

## <a name="performance-insight"></a>성능 정보

이 섹션에서는 성능 평가 방법론에 대해 설명 하 고 성능에 영향을 주는 모든 요인을 나열 합니다. 결과적으로 성능 요구 사항을 평가 하는 데 도움이 되는 메서드를 제공 합니다.

### <a name="methodology"></a>방법

*처리량* 과 *대기 시간은* 성능 확인의 두 가지 일반적인 측면입니다. Azure SignalR 서비스의 경우 각 SKU 계층에는 고유한 처리량 제한 정책이 있습니다. 이 정책은 메시지의 99%에 대기 시간이 1 초 미만인 경우 최대 *허용 처리량 (인바운드 및 아웃 바운드 대역폭)* 을 정의 합니다.

대기 시간은 Azure SignalR Service에서 응답 메시지를 수신 하기 위해 메시지를 보내는 연결의 시간 범위입니다. 예로 **echo** 를 살펴보겠습니다. 모든 클라이언트 연결은 메시지에 타임 스탬프를 추가 합니다. 앱 서버의 허브가 원래 메시지를 다시 클라이언트로 보냅니다. 따라서 모든 클라이언트 연결에서 전파 지연 시간을 쉽게 계산할 수 있습니다. 타임 스탬프는 **브로드캐스트**의 모든 메시지에 대해 첨부 되 고, **그룹에 보내고**, **연결에 전송**됩니다.

수천 개의 동시 클라이언트 연결을 시뮬레이션 하기 위해 Azure의 가상 개인 네트워크에 여러 Vm이 생성 됩니다. 이러한 모든 Vm은 동일한 Azure SignalR Service 인스턴스에 연결 됩니다.

Azure SignalR Service의 기본 모드에서 앱 서버 Vm은 클라이언트 Vm과 동일한 가상 개인 네트워크에 배포 됩니다. 모든 클라이언트 Vm 및 앱 서버 Vm은 지역 간 대기 시간을 방지 하기 위해 동일한 지역의 동일한 네트워크에 배포 됩니다.

### <a name="performance-factors"></a>성능 요인

이론적으로 Azure SignalR 서비스 용량은 CPU, 메모리 및 네트워크 계산 리소스로 제한 됩니다. 예를 들어 Azure SignalR Service에 대한 추가 연결을 사용 하면 서비스에서 더 많은 메모리를 사용 하 게 됩니다. 메시지 트래픽이 클 경우 (예: 모든 메시지가 2048 바이트 보다 큰 경우) Azure SignalR 서비스는 트래픽을 처리 하기 위해 더 많은 CPU 주기를 소비 해야 합니다. 또한 Azure 네트워크 대역폭은 최대 트래픽 제한을 부과 합니다.

전송 형식은 성능에 영향을 주는 또 다른 요소입니다. 이 세 가지 유형은 [WebSocket](https://en.wikipedia.org/wiki/WebSocket), [서버에서 보낸 이벤트](https://en.wikipedia.org/wiki/Server-sent_events)및 [긴 폴링](https://en.wikipedia.org/wiki/Push_technology)입니다. 

WebSocket은 단일 TCP 연결에 대한 양방향 및 전이중 통신 프로토콜입니다. 서버에서 보낸 이벤트는 서버에서 클라이언트로 메시지를 푸시하는 단방향 프로토콜입니다. Long 폴링을 사용 하려면 클라이언트가 HTTP 요청을 통해 서버에서 정기적으로 정보를 폴링합니다. 동일한 조건에서 동일한 API의 경우 WebSocket은 최상의 성능을 가지 며 서버에서 보낸 이벤트는 속도가 느리고 긴 폴링은 가장 느립니다. Azure SignalR Service는 기본적으로 WebSocket을 권장 합니다.

또한 메시지 라우팅 비용은 성능을 제한 합니다. Azure SignalR Service는 클라이언트 또는 서버 집합에서 다른 클라이언트나 서버로 메시지를 라우팅하는 메시지 라우터로 역할을 수행 합니다. 다른 시나리오 또는 API에는 다른 라우팅 정책이 필요 합니다. 

**Echo**의 경우 클라이언트는 자체에 메시지를 보내고 라우팅 대상은 자체입니다. 이 패턴은 라우팅 비용이 가장 낮습니다. 그러나 **브로드캐스트**, **그룹에 보내기**, **연결로 보내기**의 경우 Azure SignalR Service는 내부 분산 데이터 구조를 통해 대상 연결을 조회 해야 합니다. 이 추가 처리에서는 더 많은 CPU, 메모리 및 네트워크 대역폭을 사용 합니다. 결과적으로 성능이 느려집니다.

기본 모드에서 앱 서버는 특정 시나리오에 대해 병목 상태가 될 수도 있습니다. Azure SignalR SDK는 허브를 호출 해야 하는 반면 하트 비트 신호를 통해 모든 클라이언트와 라이브 연결을 유지 합니다.

서버를 사용 하지 않는 모드로 클라이언트는 WebSocket 만큼 효율적이 지 않은 HTTP post를 통해 메시지를 보냅니다.

또 다른 요소는 JSON 및 [MessagePack](https://msgpack.org/index.html)입니다. MessagePack는 크기가 작고 JSON 보다 더 빠르게 배달 됩니다. 그러나 MessagePack는 성능을 향상 시 키 지 않을 수 있습니다. Azure SignalR 서비스의 성능은 클라이언트에서 서버로 전달 되는 동안 메시지 페이로드를 디코드 하지 않으며, 그 반대의 경우에도 프로토콜에는 영향을 주지 않습니다.

요약 하면 인바운드 및 아웃 바운드 용량에 영향을 주는 요소는 다음과 같습니다.

-   SKU 계층 (CPU/메모리)

-   연결 수

-   메시지 크기

-   메시지 전송 율

-   전송 유형 (WebSocket, 서버-전송 이벤트 또는 긴 폴링)

-   사용 사례 시나리오 (라우팅 비용)

-   앱 서버 및 서비스 연결 (서버 모드)


### <a name="finding-a-proper-sku"></a>적절 한 SKU 찾기

인바운드/아웃 바운드 용량을 평가 하거나 특정 사용 사례에 적합 한 계층을 찾을 수 있는 방법은 무엇입니까?

앱 서버가 강력 하 고 성능 병목 상태가 아닌 것으로 가정 합니다. 그런 다음, 모든 계층에 대한 최대 인바운드 및 아웃 바운드 대역폭을 확인 합니다.

#### <a name="quick-evaluation"></a>빠른 평가

몇 가지 기본 설정을 가정 하 여 평가를 먼저 간소화 하겠습니다. 

- 전송 유형이 WebSocket입니다.
- 메시지 크기는 2048 바이트입니다.
- 메시지는 1 초 마다 전송 됩니다.
- Azure SignalR Service는 기본 모드입니다.

모든 계층에는 자체의 최대 인바운드 대역폭 및 아웃 바운드 대역폭이 있습니다. 인바운드 또는 아웃 바운드 연결이 제한을 초과 하는 경우에는 원활한 사용자 환경이 보장 되지 않습니다.

**Echo** 는 라우팅 비용이 가장 낮은 최대 인바운드 대역폭을 제공 합니다. **브로드캐스트** 는 최대 아웃 바운드 메시지 대역폭을 정의 합니다.

다음 두 테이블에서 강조 표시 된 값을 초과 *하지* 않습니다.

|       울림                        | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결                       | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| **인바운드 대역폭** | **2 MBps**    | **4 MBps**    | **10mbps**   | **20mbps**    | **40 MBps**    | **100 MBps**   | **200 MBps**    |
| 아웃 바운드 대역폭 | 2MBps   | 4MBps   | 10MBps  | 20mbps   | 40 MBps   | 100 MBps  | 200 MBps   |


|     브로드캐스트             | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000  | 100,000 |
| 인바운드 대역폭  | 4Kbps   | 4Kbps   | 4Kbps    | 4Kbps    | 4Kbps    | 4Kbps     | 4Kbps    |
| **아웃 바운드 대역폭** | **4 MBps**    | **8 MBps**    | **20mbps**    | **40 MBps**    | **80 MBps**    | **200 MBps**    | **400 MBps**   |

*인바운드 대역폭* 및 *아웃 바운드 대역폭* 은 초당 총 메시지 크기입니다.  다음은이에 대한 수식입니다.
```
  inboundBandwidth = inboundConnections * messageSize / sendInterval
  outboundBandwidth = outboundConnections * messageSize / sendInterval
```

- *inboundConnections*: 메시지를 전송 하는 연결의 수입니다.

- *outboundConnections*: 메시지를 수신 하는 연결의 수입니다.

- *messageSize*: 단일 메시지의 크기 (평균 값)입니다. 1024 바이트 미만의 작은 메시지는 1024 바이트 메시지와 유사한 성능 영향을 줍니다.

- *Sendinterval*: 메시지 하나를 보내는 시간입니다. 일반적으로 메시지 당 1 초입니다. 즉, 1 초 마다 하나의 메시지를 보냅니다. 간격은 일정 기간 동안 더 많은 메시지를 보내는 것을 의미 합니다. 예를 들어 메시지당 0.5 초는 매 초 마다 두 개의 메시지를 보내는 것을 의미 합니다.

- *연결*: 모든 계층에 대한 Azure SignalR Service의 커밋된 최대 임계값입니다. 연결 번호가 증가 하면 연결 제한이 발생 하지 않습니다.

#### <a name="evaluation-for-complex-use-cases"></a>복잡 한 사용 사례에 대한 평가

##### <a name="bigger-message-size-or-different-sending-rate"></a>더 큰 메시지 크기 또는 다른 전송 율

실제 사용 사례는 더 복잡 합니다. 2048 바이트 보다 큰 메시지를 보낼 수도 있고 보내는 메시지의 비율이 초당 메시지 하나가 아닌 경우 성능을 평가 하는 방법을 찾기 위해 Unit100's 브로드캐스트를 예로 들어 보겠습니다.

다음 표에서는 **브로드캐스트**의 실제 사용 사례를 보여 줍니다. 그러나 메시지 크기, 연결 수 및 메시지 전송 비율은 이전 섹션에서 사용한 것과 다릅니다. 이러한 항목 중 두 개만 알고 있는 경우 이러한 항목 (메시지 크기, 연결 수 또는 메시지 전송 율)을 추론 하는 방법에 대한 질문입니다.

| 브로드캐스트  | 메시지 크기 | 초당 인바운드 메시지 수 | 연결 | 전송 간격 |
|---|---------------------|--------------------------|-------------|-------------------------|
| 1 | 20KB                | 1                        | 100,000     | 5초                      |
| 2 | 256 KB               | 1                        | 8,000       | 5초                      |

이전 수식을 기반으로 다음 수식을 쉽게 유추할 수 있습니다.

```
outboundConnections = outboundBandwidth * sendInterval / messageSize
```

Unit100의 경우 최대 아웃 바운드 대역폭은 이전 테이블에서 400 MB입니다. 20KB 메시지 크기의 경우 최대 아웃 바운드 연결은 400 \* 5/20 KB = 10만 (실제 값과 일치) 여야 합니다.

##### <a name="mixed-use-cases"></a>혼합 사용 사례

실제 사용 사례는 일반적으로 네 가지 기본 사용 사례를 표시 합니다. 즉, **echo**, **브로드캐스트**, **그룹에 보내기**및 **연결에 보내기**입니다. 용량을 평가 하는 데 사용 하는 방법은 다음과 같습니다.

1. 혼합 된 사용 사례를 네 가지 기본 사용 사례로 나눕니다.
1. 위의 수식을 별도로 사용 하 여 최대 인바운드 및 아웃 바운드 메시지 대역폭을 계산 합니다.
1. 총 인바운드/아웃 바운드 대역폭을 확보 하기 위해 대역폭 계산을 합 합니다. 

그런 다음 최대 인바운드/아웃 바운드 대역폭 테이블에서 적절 한 계층을 선택 합니다.

> [!NOTE]
> 수백 또는 수천 개의 작은 그룹으로 메시지를 전송 하는 경우 또는 수천 개의 클라이언트에서 서로 메시지를 전송 하는 경우 라우팅 비용이 기준으로 청구 됩니다. 이러한 영향을 고려 합니다.

클라이언트에 메시지를 보내는 데 사용 되는 경우에는 앱 서버에 병목 상태가 발생 *하지* 않도록 해야 합니다. 다음 "사례 연구" 섹션에서는 필요한 앱 서버 수와 구성 해야 하는 서버 연결 수에 대한 지침을 제공 합니다.

## <a name="case-study"></a>사례 연구

다음 섹션에서는 WebSocket 전송에 대한 일반적인 몇 가지 사용 사례 ( **echo**, **브로드캐스트**, **그룹에 보내기**및 **연결로 보내기**)에 대해 설명 합니다. 각 시나리오에 대해 섹션에는 Azure SignalR Service에 대한 현재 인바운드 및 아웃 바운드 용량이 나열 됩니다. 또한 성능에 영향을 주는 주요 요소에 대해 설명 합니다.

기본 모드에서 앱 서버는 Azure SignalR Service를 사용 하 여 5 대의 서버 연결을 만듭니다. 앱 서버는 기본적으로 Azure SignalR Service SDK를 사용 합니다. 다음 성능 테스트 결과에서 서버 연결은 15 (또는 큰 그룹에 메시지를 브로드캐스팅 하 고 전송 하는 경우 더 많이)로 증가 합니다.

사용 사례 마다 앱 서버에 대한 요구 사항이 다릅니다. **브로드캐스트** 에는 적은 수의 앱 서버가 필요 합니다. **Echo** 또는 **connection to send에** 는 많은 앱 서버가 필요 합니다.

모든 사용 사례에서 기본 메시지 크기는 2048 바이트이 고 메시지 송신 간격은 1 초입니다.

### <a name="default-mode"></a>기본 모드

클라이언트, 웹 앱 서버 및 Azure SignalR 서비스는 기본 모드와 관련이 있습니다. 모든 클라이언트는 단일 연결을 나타냅니다.

#### <a name="echo"></a>울림

먼저 웹 앱이 Azure SignalR Service에 연결 합니다. 두 번째로 많은 클라이언트는 웹 앱에 연결 되며,이는 클라이언트를 액세스 토큰 및 엔드포인트을 사용 하 여 Azure SignalR Service로 리디렉션합니다. 그런 다음 클라이언트가 Azure SignalR Service를 사용 하 여 WebSocket 연결을 설정 합니다.

모든 클라이언트는 연결을 설정한 후 초 마다 특정 허브에 타임 스탬프를 포함 하는 메시지 보내기를 시작 합니다. 허브는 메시지를 원래 클라이언트에 다시 에코 합니다. 모든 클라이언트는 echo 메시지를 다시 수신할 때 대기 시간을 계산 합니다.

다음 다이어그램에서 5 ~ 8 (빨간색으로 강조 표시 된 트래픽)은 루프에 있습니다. 루프는 기본 기간 (5 분) 동안 실행 되 고 모든 메시지 대기 시간에 대한 통계를 가져옵니다.

![Echo 사용 사례에 대한 트래픽](./media/signalr-concept-performance/echo.png)

**Echo** 동작은 최대 인바운드 대역폭이 최대 아웃 바운드 대역폭과 같음을 결정 합니다. 자세한 내용은 다음 표를 참조 하세요.

|       울림                        | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결                       | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 초당 인바운드/아웃 바운드 메시지 수 | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 인바운드/아웃 바운드 대역폭 | 2MBps   | 4MBps   | 10MBps  | 20mbps   | 40 MBps   | 100 MBps  | 200 MBps   |

이 사용 사례에서 모든 클라이언트는 앱 서버에 정의 된 허브를 호출 합니다. 허브는 원래 클라이언트 쪽에 정의 된 메서드만 호출 합니다. 이 허브는 **에코**를 위한 가장 경량 허브입니다.

```
        public void Echo(IDictionary<string, object> data)
        {
            Clients.Client(Context.ConnectionId).SendAsync("RecordLatency", data);
        }
```

이 간단한 허브의 경우에도 응용 프로그램 서버에 대한 트래픽 압력은 **에코** 인바운드 메시지 부하가 증가할 때 강조 됩니다. 이러한 트래픽 압력에는 많은 SKU 계층에 대한 많은 앱 서버가 필요 합니다. 다음 표에서는 모든 계층에 대한 앱 서버 수를 나열 합니다.


|    울림          | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 앱 서버의 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, SKU 계층 및 CPU/메모리는 **에코**의 전반적인 성능에 영향을 줍니다.

#### <a name="broadcast"></a>브로드캐스트

**브로드캐스트**의 경우 웹 앱은 메시지를 받으면 모든 클라이언트에 브로드캐스트합니다. 브로드캐스트할 클라이언트가 많을 수록 모든 클라이언트에 대한 추가 메시지 트래픽이 발생 합니다. 다음 다이어그램을 참조 하세요.

![브로드캐스트 사용 사례에 대한 트래픽](./media/signalr-concept-performance/broadcast.png)

적은 수의 클라이언트가 브로드캐스팅 중입니다. 인바운드 메시지 대역폭은 작지만 아웃 바운드 대역폭은 큽니다. 아웃 바운드 메시지 대역폭은 클라이언트 연결 또는 브로드캐스트 요금이 증가할 때 늘어납니다.

다음 표에는 최대 클라이언트 연결 수, 인바운드/아웃 바운드 메시지 수 및 대역폭이 요약 되어 있습니다.

|     브로드캐스트             | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지 수  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 초당 아웃 바운드 메시지 수 | 2, 000 | 4,000 | 10,000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭  | 4Kbps   | 4Kbps   | 4Kbps    | 4Kbps    | 4Kbps    | 4Kbps     | 4Kbps     |
| 아웃 바운드 대역폭 | 4MBps   | 8MBps   | 20mbps   | 40 MBps   | 80 MBps   | 200 MBps   | 400 MBps   |

메시지를 게시 하는 브로드캐스팅 클라이언트는 4 개이 하입니다. 인바운드 메시지 양이 적기 때문에 **에코** 와 비교할 때 더 적은 수의 앱 서버가 필요 합니다. 두 개의 앱 서버는 SLA 및 성능 고려 사항에 충분 합니다. 그러나 Unit50 및 Unit100의 경우에는 불균형을 방지 하기 위해 기본 서버 연결을 늘려야 합니다.

|   브로드캐스트      | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
> Azure SignalR Service에 대한 불균형 서버 연결을 방지 하려면 모든 앱 서버에서 기본 서버 연결 수를 5에서 40로 늘립니다.
>
> 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도 및 SKU 계층은 **브로드캐스트**에 대한 전반적인 성능에 영향을 줍니다.

#### <a name="send-to-group"></a>그룹으로 보내기

**그룹에 보내기** 사용 사례에는 **브로드캐스트**에 비슷한 트래픽 패턴이 있습니다. 차이점은 클라이언트가 Azure SignalR Service를 사용 하 여 WebSocket 연결을 설정한 후에 그룹을 조인 해야 특정 그룹에 메시지를 보낼 수 있다는 것입니다. 다음 다이어그램은 트래픽 흐름을 보여 줍니다.

![그룹 송신 사용 사례에 대한 트래픽](./media/signalr-concept-performance/sendtogroup.png)

그룹 구성원 및 그룹 수는 성능에 영향을 주는 두 가지 요소입니다. 분석을 간소화 하기 위해 다음과 같은 두 종류의 그룹을 정의 합니다.

- **작은 그룹**: 모든 그룹에는 10 개의 연결이 있습니다. 그룹 번호는 (최대 연결 수)/10과 같습니다. 예를 들어 Unit1의 경우 1000 연결 수가 있는 경우 1000/10 = 100 그룹이 있습니다.

- **빅 그룹**: 그룹 번호는 항상 10입니다. 그룹 구성원 수는 (최대 연결 수)/10과 같습니다. 예를 들어 Unit1의 경우 1000 연결 수가 있는 경우 모든 그룹에 1000/10 = 100 멤버가 있습니다.

**그룹에 보내기** 는 분산 데이터 구조를 통해 대상 연결을 찾아야 하므로 Azure SignalR Service에 대한 라우팅 비용을 가져옵니다. 전송 연결이 늘어나면 비용이 증가 합니다.

##### <a name="small-group"></a>작은 그룹

라우팅 비용은 여러 작은 그룹으로 메시지를 보내는 데 중요 합니다. 현재 Azure SignalR 서비스 구현은 Unit50에서 라우팅 비용 한도에 도달 합니다. CPU와 메모리를 더 추가 하는 것은 도움이 되지 않으므로 Unit100은 설계를 통해 더 이상 향상 시킬 수 없습니다. 인바운드 대역폭이 더 필요 하면 고객 지원에 문의 하세요.

|   작은 그룹으로 보내기     | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50 | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|--------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000 | 100,000
| 그룹 구성원 수        | 10    | 10    | 10     | 10     | 10     | 10     | 10 
| 그룹 수               | 100   | 200   | 500    | 1,000  | 2, 000  | 5,000  | 10,000 
| 초당 인바운드 메시지 수  | 200   | 400   | 1,000  | 2,500  | 4,000  | 7,000  | 7,000   |
| 인바운드 대역폭  | 400 KBps  | 800 KBps  | 2MBps     | 5MBps     | 8MBps     | 14mbps    | 14mbps     |
| 초당 아웃 바운드 메시지 수 | 2, 000 | 4,000 | 10,000 | 25,000 | 40,000 | 70,000 | 70,000  |
| 아웃 바운드 대역폭 | 4MBps    | 8MBps    | 20mbps    | 50 MBps     | 80 MBps    | 140 MBps   | 140 MBps    |

많은 클라이언트 연결에서 허브를 호출 하므로 앱 서버 번호는 성능에도 중요 합니다. 다음 표에는 제안 된 앱 서버 수가 나와 있습니다.

|  작은 그룹으로 보내기   | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 앱 서버의 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용, SKU 계층 및 CPU/메모리는 **작은 그룹에 보내는**전체 성능에 영향을 줍니다.

##### <a name="big-group"></a>큰 그룹

**대규모 그룹으로 보내기**의 경우 라우팅 비용 제한에 도달 하기 전에 아웃 바운드 대역폭이 병목 상태가 됩니다. 다음 표에서는 **브로드캐스트**에 대한 최대 아웃 바운드 대역폭을 나열 합니다.

|    빅 그룹으로 보내기      | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000  | 100,000
| 그룹 구성원 수        | 100   | 200   | 500    | 1,000  | 2, 000  | 5,000   | 10,000 
| 그룹 수               | 10    | 10    | 10     | 10     | 10     | 10      | 10
| 초당 인바운드 메시지 수  | 20    | 20    | 20     | 20     | 20     | 20      | 20      |
| 인바운드 대역폭  | 80 KBps   | 40 KBps   | 40 KBps    | 20kbps    | 40 KBps    | 40 KBps     | 40 KBps     |
| 초당 아웃 바운드 메시지 수 | 2, 000 | 4,000 | 10,000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 아웃 바운드 대역폭 | 8MBps    | 8MBps    | 20mbps    | 40 MBps    | 80 MBps    | 200 MBps    | 400 MBps    |

전송 연결 수가 40을 초과 하지 않습니다. 앱 서버의 부담은 작으므로 제안 된 수의 웹 앱은 작습니다.

|  빅 그룹으로 보내기  | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
> Azure SignalR Service에 대한 불균형 서버 연결을 방지 하려면 모든 앱 서버에서 기본 서버 연결 수를 5에서 40로 늘립니다.
> 
> 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용 및 SKU 계층은 **빅 그룹에 전송**의 전반적인 성능에 영향을 줍니다.

#### <a name="send-to-connection"></a>연결로 보내기

**연결에 보내기** 사용 사례에서 클라이언트가 Azure SignalR Service에 대한 연결을 설정 하는 경우 모든 클라이언트는 특별 한 허브를 호출 하 여 고유한 연결 ID를 가져옵니다. 성능 벤치 마크는 모든 연결 Id를 수집 하 고 섞 습니다 모든 클라이언트에 보내는 대상으로 다시 할당 합니다. 클라이언트는 성능 테스트가 완료 될 때까지 대상 연결에 메시지를 계속 보냅니다.

![클라이언트에서 보내는 사용 사례에 대한 트래픽](./media/signalr-concept-performance/sendtoclient.png)

**연결에 보내기** 에 대한 라우팅 비용은 **소규모 그룹으로 보내기**에 대한 비용과 비슷합니다.

연결 수가 늘어나면 라우팅 비용은 전반적인 성능을 제한 합니다. Unit50가 한도에 도달 했습니다. 따라서 Unit100는 더 이상 향상 시킬 수 없습니다.

다음 표는 **연결로 보내기** 벤치 마크를 실행 하는 여러 라운드 후의 통계 요약입니다.

|   연결로 보내기   | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50          | Unit100         |
|------------------------------------|-------|-------|-------|--------|--------|-----------------|-----------------|
| 연결                        | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000          | 100,000         |
| 초당 인바운드/아웃 바운드 메시지 수 | 1,000 | 2, 000 | 5,000 | 8,000  | 9,000  | 20,000 | 20,000 |
| 인바운드/아웃 바운드 대역폭 | 2MBps    | 4MBps    | 10MBps   | 16mbps    | 18mbps    | 40 MBps       | 40 MBps       |

이 사용 사례에는 앱 서버 쪽의 높은 부하가 필요 합니다. 다음 표에서 제안 된 앱 서버 수를 참조 하세요.

|  연결로 보내기  | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 응용 프로그램 서버에 대한 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용, SKU 계층 및 CPU/메모리는 **연결 보내기**의 전반적인 성능에 영향을 줍니다.

#### <a name="aspnet-signalr-echo-broadcast-and-send-to-small-group"></a>ASP.NET SignalR echo, 브로드캐스트 및 작은 그룹으로 보내기

Azure SignalR Service는 ASP.NET SignalR에 대해 동일한 성능 용량을 제공 합니다. 

성능 테스트는 ASP.NET SignalR에 대한 [표준 서비스 계획 S3](https://azure.microsoft.com/pricing/details/app-service/windows/) 의 Azure Web Apps를 사용 합니다.

다음 표에서는 ASP.NET SignalR **echo**에 대해 제안 된 웹 앱 수를 제공 합니다.

|   울림           | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

다음 표에서는 ASP.NET SignalR **브로드캐스트**에 대해 제안 된 웹 앱 수를 제공 합니다.

|  브로드캐스트       | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

다음 표에서는 ASP.NET SignalR **send to small group**에 대해 제안 된 웹 앱 수를 제공 합니다.

|  작은 그룹으로 보내기     | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2, 000 | 5,000 | 10,000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

### <a name="serverless-mode"></a>서버 리스 모드

클라이언트 및 Azure SignalR 서비스는 서버 리스 모드와 관련이 있습니다. 모든 클라이언트는 단일 연결을 나타냅니다. 클라이언트는 REST API를 통해 다른 클라이언트에 메시지를 전송 하거나 메시지를 모든 메시지에 보냅니다.

REST API를 통해 고밀도 메시지를 보내는 것은 WebSocket을 사용 하는 것 만큼 효율적이 지 않습니다. 이렇게 하려면 매번 새 HTTP 연결을 작성 해야 하며,이는 서버 리스 모드에서 추가 비용입니다.

#### <a name="broadcast-through-rest-api"></a>REST API 브로드캐스트
모든 클라이언트는 Azure SignalR Service를 사용 하 여 WebSocket 연결을 설정 합니다. 그런 다음 일부 클라이언트는 REST API를 통해 브로드캐스팅을 시작 합니다. 메시지 보내기 (인바운드)는 모두 HTTP Post를 통해 사용 되며, WebSocket과는 효율적이 지 않습니다.

|   REST API 브로드캐스트     | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지 수  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 초당 아웃 바운드 메시지 수 | 2, 000 | 4,000 | 10,000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭  | 4Kbps    | 4Kbps    | 4Kbps     | 4Kbps     | 4Kbps     | 4Kbps      | 4Kbps      |
| 아웃 바운드 대역폭 | 4MBps    | 8MBps    | 20mbps    | 40 MBps    | 80 MBps    | 200 MBps    | 400 MBps    |

#### <a name="send-to-user-through-rest-api"></a>REST API를 통해 사용자에 게 보내기
벤치 마크는 Azure SignalR Service에 대한 연결을 시작 하기 전에 모든 클라이언트에 사용자 이름을 할당 합니다. 클라이언트가 Azure SignalR Service를 사용 하 여 WebSocket 연결을 설정 하면 HTTP Post를 통해 다른 사용자에 게 메시지를 보내기 시작 합니다.

|   REST API를 통해 사용자에 게 보내기 | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2, 000 | 5,000  | 10,000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지 수  | 300   | 600   | 900    | 1,300  | 2, 000  | 10,000  | 18,000  |
| 초당 아웃 바운드 메시지 수 | 300   | 600   | 900    | 1,300  | 2, 000  | 10,000  | 18,000 |
| 인바운드 대역폭  | 600 KBps  | 1.2 MBps  | 1.8 MBps   | 2.6 MBps   | 4MBps     | 10MBps     | 36 MBps    |
| 아웃 바운드 대역폭 | 600 KBps  | 1.2 MBps  | 1.8 MBps   | 2.6 MBps   | 4MBps     | 10MBps     | 36 MBps    |

## <a name="performance-test-environments"></a>성능 테스트 환경

앞에서 나열한 모든 사용 사례에 대해 Azure 환경에서 성능 테스트를 수행 했습니다. 최대 50 클라이언트 Vm 및 20 개의 앱 서버 Vm을 사용 했습니다. 자세한 내용은 다음과 같습니다.

- 클라이언트 VM 크기: StandardDS2V2 (2 개 vCPU, 7G 메모리)

- 앱 서버 VM 크기: StandardF4sV2 (4 개 vCPU, 8G 메모리)

- Azure SignalR SDK 서버 연결: 15

## <a name="performance-tools"></a>성능 도구

Azure SignalR Service에 대한 성능 도구는 [GitHub](https://github.com/Azure/azure-signalr-bench/)에서 찾을 수 있습니다.

## <a name="next-steps"></a>다음 단계

이 문서에서는 일반적인 사용 사례 시나리오에서 Azure SignalR Service 성능에 대한 개요를 얻었습니다.

서비스의 내부 및 확장성에 대한 자세한 내용은 다음 가이드를 참조 하세요.

* [Azure SignalR Service 내부 기능](signalr-concept-internals.md)
* [Azure SignalR 서비스 크기 조정](signalr-howto-scale-multi-instances.md)
