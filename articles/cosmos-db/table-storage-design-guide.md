---
title: 크기 조정 및 성능을 위한 테이블 Azure Cosmos DB 디자인
description: 'Azure 테이블 저장소 디자인 가이드: Azure Cosmos DB 및 Azure Table storage의 확장 가능 하 고 성능이 뛰어난 테이블'
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 05/21/2019
author: sakash279
ms.author: akshanka
ms.custom: seodec18
ms.openlocfilehash: 166076d366cbbf7bef24648772beaba9b3a88253
ms.sourcegitcommit: 984c5b53851be35c7c3148dcd4dfd2a93cebe49f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/28/2020
ms.locfileid: "76771528"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Azure 테이블 저장소 테이블 디자인 가이드: 확장 가능 하 고 성능이 뛰어난 테이블

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

확장 가능하고 성능이 뛰어난 테이블을 디자인하려면 비용을 비롯한 다양한 요인을 고려해야 합니다. 이전에 관계형 데이터베이스에 대한 스키마를 디자인한 적이 있다면 이러한 고려 사항이 익숙할 것입니다. 그러나 Azure Table Storage와 관계형 모델 간에는 몇 가지 유사점이 있지만 중요한 차이점도 많이 있습니다. 이러한 차이점으로 인해 일반적으로 관계형 데이터베이스에 익숙한 사용자에게는 직관에 반하거나 잘못된 것으로 보일 수 있지만 Table Storage와 같은 NoSQL 키/값 저장소를 디자인하는 경우에는 매우 적절한 다른 디자인이 도출됩니다.

테이블 저장소는 수십억 개의 엔터티 (관계형 데이터베이스 용어에 있는 "행") 또는 높은 트랜잭션 볼륨을 지원 해야 하는 데이터 집합을 포함할 수 있는 클라우드 규모의 응용 프로그램을 지원 하도록 설계 되었습니다. 따라서 데이터를 저장 하는 방법에 대해 다르게 생각해 보고 테이블 저장소의 작동 방식을 이해 해야 합니다. 잘 디자인 된 NoSQL 데이터 저장소를 사용 하면 솔루션을 관계형 데이터베이스를 사용 하는 솔루션 보다 훨씬 더 저렴 한 비용으로 확장할 수 있습니다. 이 가이드에서는 이러한 항목에 대해 설명합니다.  

## <a name="about-azure-table-storage"></a>Azure 테이블 저장소 정보
이 섹션에서는 성능 및 확장성에 대한 디자인과 특별히 관련 된 테이블 저장소의 주요 기능 중 일부를 중점적으로 설명 합니다. Azure Storage 및 테이블 저장소를 처음 접하는 경우이 문서의 나머지 부분을 읽기 전에 [Microsoft Azure Storage 소개](../storage/common/storage-introduction.md) 및 [.net을 사용 하 여 Azure Table Storage 시작](table-storage-how-to-use-dotnet.md) 을 참조 하세요. 이 가이드의 초점은 테이블 저장소에 대한 것 이지만, Azure Queue storage 및 Azure Blob storage에 대해 설명 하 고 솔루션의 테이블 저장소와 함께 사용할 수 있는 방법을 포함 합니다.  

테이블 저장소는 테이블 형식을 사용 하 여 데이터를 저장 합니다. 표준 용어로, 테이블의 각 행은 엔터티를 나타내고 행은 해당 엔터티의 여러 속성을 저장합니다. 모든 엔터티에는 해당 엔터티를 고유 하 게 식별 하는 키 쌍과 테이블 저장소에서 엔터티를 마지막으로 업데이트 한 시간을 추적 하는 데 사용 하는 타임 스탬프 열이 있습니다. 타임 스탬프 필드는 자동으로 추가 되며, 타임 스탬프를 임의 값으로 수동으로 덮어쓸 수 없습니다. Table storage는이 LMT (마지막 수정 타임 스탬프)를 사용 하 여 낙관적 동시성을 관리 합니다.  

> [!NOTE]
> Table storage REST API 연산은 LMT에서 파생 되는 `ETag` 값도 반환 합니다. 이 문서에서 ETag와 LMT 라는 용어는 동일한 기본 데이터를 참조 하므로 서로 다른 의미로 사용 됩니다.  
> 
> 

다음 예제에서는 직원 및 부서 엔터티를 저장하는 간단한 테이블 디자인을 보여 줍니다. 이 가이드의 뒷부분에 나오는 예제는 대부분 이 간단한 디자인을 기반으로 합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td>마케팅</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>마케팅</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>6월</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>마케팅</td>
<td>department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>마케팅</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>영업</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


지금 까지는이 디자인이 관계형 데이터베이스의 테이블과 유사 하 게 보입니다. 주요 차이점은 필수 열과 여러 엔터티 형식을 동일한 테이블에 저장 하는 기능입니다. 또한 **FirstName** 또는 **Age**와 같은 각 사용자 정의 속성에는 관계형 데이터베이스의 열과 마찬가지로 정수 또는 문자열과 같은 데이터 형식이 있습니다. 그러나 관계형 데이터베이스에서와 달리 테이블 저장소의 스키마가 없는 특성은 속성의 데이터 형식이 각 엔터티에 동일 하지 않아도 된다는 것을 의미 합니다. 복잡한 데이터 형식을 단일 속성에 저장하려면 JSON 또는 XML과 같은 직렬화된 형식을 사용해야 합니다. 자세한 내용은 [테이블 저장소 데이터 모델 이해](https://msdn.microsoft.com/library/azure/dd179338.aspx)를 참조 하세요.

`PartitionKey` 및 `RowKey` 선택은 좋은 테이블 디자인의 기본입니다. 테이블에 저장 된 모든 엔터티에는 `PartitionKey` 및 `RowKey`의 고유한 조합이 있어야 합니다. 관계형 데이터베이스 테이블의 키와 마찬가지로 `PartitionKey` 및 `RowKey` 값은 인덱스 되어 빠른 조회를 가능 하 게 하는 클러스터형 인덱스를 만듭니다. 그러나 테이블 저장소는 보조 인덱스를 만들지 않으므로 두 개의 인덱싱된 속성만 사용 합니다. 나중에 설명 하는 패턴 중 일부는 이러한 명백한 제한을 해결할 수 있는 방법을 보여 줍니다.  

테이블은 하나 이상의 파티션으로 구성 되며, 결정 하는 많은 디자인 결정은 적절 한 `PartitionKey`를 선택 하 고 솔루션을 최적화 하는 데 `RowKey` 됩니다. 솔루션은 파티션으로 구성 된 모든 엔터티를 포함 하는 단일 테이블로만 구성 될 수 있지만 일반적으로 솔루션에는 여러 테이블이 있습니다. 테이블은 엔터티를 논리적으로 구성 하는 데 도움이 되며 액세스 제어 목록을 사용 하 여 데이터에 대한 액세스를 관리 하는 데 도움이 됩니다. 단일 저장소 작업을 사용 하 여 전체 테이블을 삭제할 수 있습니다.  

### <a name="table-partitions"></a>테이블 파티션
계정 이름, 테이블 이름 및 `PartitionKey` 함께 저장소 서비스 내에서 테이블 저장소에 엔터티를 저장 하는 파티션을 식별 합니다. 파티션은 엔터티에 대한 주소 지정 체계의 일부가 될 뿐만 아니라 트랜잭션의 범위를 정의 합니다 (이 문서의 뒷부분에 나오는 섹션 참조, [엔터티 그룹 트랜잭션](#entity-group-transactions)). 테이블 파티션에 대한 자세한 내용은 [테이블 저장소에 대한 성능 및 확장성 검사 목록](../storage/tables/storage-performance-checklist.md)을 참조 하세요.  

테이블 저장소에서 개별 노드는 하나 이상의 전체 파티션을 지원 하며, 서비스는 노드 간에 파티션을 동적으로 부하 분산 하 여 크기를 조정 합니다. 노드가 부하 상태 이면 테이블 저장소는 해당 노드에서 처리 하는 파티션의 범위를 다른 노드로 분할할 수 있습니다. 트래픽 하위 면에서 Table storage는 자동 노드의 파티션 범위를 단일 노드로 다시 병합할 수 있습니다.  

테이블 저장소의 내부 세부 정보 및 특히 파티션을 관리 하는 방법에 대한 자세한 내용은 [Microsoft Azure Storage: 강력한 일관성과 함께 항상 사용 가능한 클라우드 저장소 서비스](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)를 참조 하세요.  

### <a name="entity-group-transactions"></a>엔터티 그룹 트랜잭션
테이블 저장소에서는 여러 엔터티에서 원자성 업데이트를 수행 하는 유일한 기본 제공 메커니즘은 엔터티 그룹 트랜잭션 (균형 있는 그룹 트랜잭션)입니다. 이러한 작업을 *일괄 처리 트랜잭션*이 라고도 합니다. 같은 파티션에 저장 된 엔터티 (특정 테이블의 동일한 파티션 키 공유)에 대해서만 균형 있게 작업을 수행할 수 있으므로 여러 엔터티에서 원자성 트랜잭션 동작을 수행 해야 할 때마다 해당 엔터티가 동일한 파티션에 있는지 확인 합니다. 이는 여러 엔터티 형식을 여러 엔터티 형식에 대해 사용 하지 않고 동일한 테이블 및 파티션에 유지 하는 이유입니다. 단일 EGT는 최대 100개의 엔터티에서 작동할 수 있습니다.  처리를 위해 동시에 여러 사용자를 제출 하는 경우 해당 하는 사람이 회사 간에 공통적인 엔터티에서 작동 하지 않도록 하는 것이 중요 합니다. 그렇지 않으면 처리가 지연 될 위험이 있습니다.

EGT는 디자인을 평가하기 위해 잠재적인 장단점에 대해서도 소개합니다. Azure에는 노드 간 부하 분산 요청에 대한 기회가 더 있으므로 더 많은 파티션을 사용 하면 응용 프로그램의 확장성이 향상 됩니다. 그러나이로 인해 응용 프로그램의 기능을 제한 하 여 원자성 트랜잭션을 수행 하 고 데이터에 대한 강력한 일관성을 유지할 수 있습니다. 또한 단일 노드에서 예상할 수 있는 트랜잭션 처리량을 제한할 수 있는 파티션 수준에서 특정 확장성 목표가 있습니다.

Azure storage 계정의 확장성 목표에 대한 자세한 내용은 [standard storage 계정에 대한 확장성 목표](../storage/common/scalability-targets-standard-account.md)를 참조 하세요. 테이블 저장소의 확장성 목표에 대한 자세한 내용은 [테이블 저장소에 대한 확장성 및 성능 목표](../storage/tables/scalability-targets.md)를 참조 하세요. 이 가이드의 뒷부분에 나오는 섹션에서는 이와 같은 장단점을 관리하는 데 도움이 되는 여러 가지 디자인 전략을 소개하고, 클라이언트 애플리케이션의 특정 요구 사항에 따라 파티션 키를 선택하는 최상의 방법을 설명합니다.  

### <a name="capacity-considerations"></a>용량 고려 사항
다음 표에는 테이블 저장소 솔루션을 디자인 하는 경우 알아야 할 몇 가지 키 값이 나와 있습니다.  

| Azure Storage 계정의 총 용량 | 500TB |
| --- | --- |
| Azure Storage 계정에서 테이블의 수 |저장소 계정 용량에 의해서만 제한 됩니다. |
| 테이블에 있는 파티션 수 |저장소 계정 용량에 의해서만 제한 됩니다. |
| 파티션의 엔터티 수 |저장소 계정 용량에 의해서만 제한 됩니다. |
| 개별 엔터티의 크기 |최대 1mb, 최대 255 속성 (`PartitionKey`, `RowKey`및 `Timestamp`포함) |
| `PartitionKey` 크기 |최대 1kb 크기의 문자열입니다. |
| `RowKey` 크기 |최대 1kb 크기의 문자열입니다. |
| 엔터티 그룹 트랜잭션의 크기 |트랜잭션은 최대 100 개의 엔터티를 포함할 수 있으며 페이로드 크기는 4mb 미만 이어야 합니다. EGT는 한 번에 하나의 엔터티만 업데이트할 수 있음 |

자세한 내용은 [Table service 데이터 모델 이해](https://msdn.microsoft.com/library/azure/dd179338.aspx)를 참조 하세요.  

### <a name="cost-considerations"></a>비용 고려 사항
테이블 저장소는 비교적 저렴 하지만 테이블 저장소를 사용 하는 솔루션 평가의 일환으로 용량 사용량과 트랜잭션 수량에 대한 예상 비용을 포함 해야 합니다. 그러나 대부분의 시나리오에서는 솔루션의 성능이 나 확장성을 향상 시키기 위해 비 정규화 되거나 중복 된 데이터를 저장 하는 것이 유효한 방법입니다. 가격 책정에 대한 자세한 내용은 [Azure Storage 가격](https://azure.microsoft.com/pricing/details/storage/)을 참조하세요.  

## <a name="guidelines-for-table-design"></a>테이블 디자인 지침
이러한 목록에는 테이블을 디자인할 때 염두에 두어야 하는 몇 가지 주요 지침이 요약 되어 있습니다. 이 가이드는 나중에 자세히 설명 합니다. 이러한 지침은 관계형 데이터베이스 디자인을 위해 일반적으로 수행 하는 지침과 다릅니다.  

효율적으로 *읽을* 수 있도록 테이블 저장소 디자인:

* **읽기 작업이 많은 애플리케이션의 쿼리를 위해 디자인합니다.** 테이블을 디자인 하는 경우 엔터티를 업데이트 하는 방법을 고려 하기 전에 실행 하는 쿼리 (특히 대기 시간이 중요 한 쿼리)에 대해 생각해 보십시오. 이는 일반적으로 솔루션의 효율성 및 성능에 영향을 줍니다.  
* **쿼리에서 `PartitionKey`와 `RowKey`를 모두 지정 합니다.** 이와 같은 *지점 쿼리* 는 가장 효율적인 테이블 저장소 쿼리입니다.  
* **엔터티의 중복 복사본을 저장하는 것이 좋습니다.** 테이블 저장소는 저렴 하므로 더 효율적인 쿼리를 사용할 수 있도록 동일한 엔터티를 여러 번 (다른 키와 함께) 저장 하는 것이 좋습니다.  
* **데이터를 비정규화하는 것이 좋습니다.** 테이블 저장소는 저렴 하므로 데이터를 비 정규화 하는 것이 좋습니다. 예를 들어 집계 데이터에 대한 쿼리에서 단일 엔터티에만 액세스하면 되도록 요약 엔터티를 저장합니다.  
* **복합 키 값을 사용하는 것이 좋습니다.** `PartitionKey` 및 `RowKey`키만 있습니다. 예를 들어 복합 키 값을 사용하여 엔터티에 대한 대체 키 액세스 경로를 사용하도록 설정할 수 있습니다.  
* **쿼리 프로젝션을 사용합니다.** 필요한 필드만 선택하는 쿼리를 사용하여 네트워크를 통해 전송하는 데이터 양을 줄일 수 있습니다.  

효율적으로 *작성할* 수 있도록 테이블 저장소 디자인:  

* **핫 파티션을 만들지 마세요.** 언제든 여러 파티션으로 요청을 분산할 수 있는 키를 선택합니다.  
* **트래픽 급증을 방지합니다.** 적절 한 시간 동안 트래픽을 분산 하 고 트래픽 급증을 방지 합니다.
* **각 엔터티 유형에 대한 별도의 테이블을 만들 필요가 없습니다.** 엔터티 유형 간에 원자성 트랜잭션이 필요한 경우 이러한 여러 엔터티 유형을 동일한 테이블의 동일한 파티션에 저장할 수 있습니다.
* **달성해야 하는 최대 처리량을 고려합니다.** 테이블 저장소에 대한 확장성 목표를 파악 하 고 디자인으로 인해 이러한 목표를 초과 하지 않도록 해야 합니다.  

이 가이드의 뒷부분에 이러한 모든 원칙을 적용 하는 예제가 나와 있습니다.  

## <a name="design-for-querying"></a>쿼리를 위한 디자인
테이블 저장소는 읽기 집약적 이거나 쓰기 집약적 이거나 둘을 혼합할 수 있습니다. 이 섹션에서는 읽기 작업을 효율적으로 지 원하는 디자인을 고려 합니다. 일반적으로 읽기 작업을 효율적으로 지원하는 디자인은 쓰기 작업에도 효율적입니다. 그러나 쓰기 작업을 지원 하도록 디자인할 때는 추가로 고려해 야 할 사항이 있습니다. 이러한 내용은 다음 섹션인 [데이터 수정을 위한 디자인](#design-for-data-modification)에 설명 되어 있습니다.

데이터를 효율적으로 읽을 수 있는 출발점은 "응용 프로그램에서 필요한 데이터를 검색 하기 위해 실행 해야 하는 쿼리"를 확인 하는 것입니다.  

> [!NOTE]
> 테이블 저장소를 사용 하면 나중에 디자인을 수정 하는 것이 중요 합니다. 나중에 변경 하는 것이 어렵고 비용이 많이 들기 때문입니다. 예를 들어 관계형 데이터베이스에서는 기존 데이터베이스에 인덱스를 추가 하는 것 만으로 성능 문제를 해결할 수 있는 경우가 많습니다. 이 옵션은 테이블 저장소에서 선택할 수 없습니다.  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>선택한 `PartitionKey` 및 `RowKey`가 쿼리 성능에 미치는 영향
다음 예에서는 테이블 저장소에서 다음 구조의 직원 엔터티를 저장 한다고 가정 합니다. 대부분의 예제에서는 명확 하 게 하기 위해 `Timestamp` 속성을 생략 합니다.  

| 열 이름 | 데이터 형식 |
| --- | --- |
| `PartitionKey` (부서 이름) |String |
| `RowKey` (직원 ID) |String |
| `FirstName` |String |
| `LastName` |String |
| `Age` |정수 |
| `EmailAddress` |String |

테이블 저장소 쿼리를 디자인 하기 위한 몇 가지 일반적인 지침은 다음과 같습니다. 다음 예제에 사용 된 필터 구문은 테이블 저장소 REST API에서 가져온 것입니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조 하세요.  

* *지점 쿼리* 는 가장 효율적으로 사용할 수 있는 조회 이며, 높은 볼륨 조회 또는 가장 짧은 대기 시간을 요구 하는 조회에 권장 됩니다. 이러한 쿼리는 `PartitionKey` 및 `RowKey` 값을 모두 지정 하 여 인덱스를 사용 하 여 개별 엔터티를 효율적으로 찾을 수 있습니다. 예: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`  
* 두 번째 최상의 방법은 *범위 쿼리입니다*. `PartitionKey`를 사용 하 고 `RowKey` 값 범위에 대한 필터를 사용 하 여 둘 이상의 엔터티를 반환 합니다. `PartitionKey` 값은 특정 파티션을 식별 하 고 `RowKey` 값은 해당 파티션에 있는 엔터티의 하위 집합을 식별 합니다. 예: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`  
* 세 번째 최상의 *파티션은 파티션 검색*입니다. `PartitionKey`를 사용 하 고 키가 아닌 다른 속성을 필터링 하 여 둘 이상의 엔터티를 반환할 수 있습니다. `PartitionKey` 값은 특정 파티션을 식별 하 고, 속성 값은 해당 파티션에 있는 엔터티의 하위 집합에 대해 선택 합니다. 예: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`  
* *테이블 검색* 은 `PartitionKey`를 포함 하지 않으며 테이블을 구성 하는 모든 파티션을 검색 하 여 일치 하는 엔터티로 검색 하므로 비효율적입니다. 필터가 `RowKey`를 사용 하는지 여부에 관계 없이 테이블 검색을 수행 합니다. 예: `$filter=LastName eq 'Jones'`  
* 여러 엔터티를 반환 하는 Azure Table storage 쿼리는 `PartitionKey` 및 `RowKey` 순서로 정렬 합니다. 클라이언트에서 엔터티를 순서 대로 정렬 하지 않으려면 가장 일반적인 정렬 순서를 정의 하는 `RowKey`를 선택 합니다. Azure Cosmos DB에서 Azure Table API에 의해 반환 된 쿼리 결과는 파티션 키 또는 행 키를 기준으로 정렬 되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

"**Or**"를 사용 하 여 `RowKey` 값을 기준으로 필터를 지정 하면 파티션 검색이 발생 하며 범위 쿼리로 처리 되지 않습니다. 따라서 `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`와 같은 필터를 사용 하는 쿼리를 사용 하지 마십시오.  

저장소 클라이언트 라이브러리를 사용 하 여 효율적인 쿼리를 실행 하는 클라이언트 쪽 코드의 예는 다음을 참조 하세요.  

* [저장소 클라이언트 라이브러리를 사용 하 여 지점 쿼리 실행](#run-a-point-query-by-using-the-storage-client-library)
* [LINQ를 사용 하 여 여러 엔터티 검색](#retrieve-multiple-entities-by-using-linq)
* [서버 쪽 프로젝션](#server-side-projection)  

동일한 테이블에 저장된 여러 엔터티 유형을 처리할 수 있는 클라이언트 쪽 코드의 예는 다음을 참조하세요.  

* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>적절 한 `PartitionKey` 선택
`PartitionKey` 선택 하는 경우 여러 파티션에 엔터티를 배포 하는 요구 사항에 대한 균형을 유지 하기 위해 (확장 가능한 솔루션을 보장 하기 위해) 균형을 유지 하는 데 필요한 요구 사항을 균형 있게 유지 해야 합니다.  

한 가지 극단적인 경우 모든 엔터티를 단일 파티션에 저장할 수 있습니다. 그러나 이렇게 하면 솔루션의 확장성이 제한 될 수 있으며, 테이블 저장소에서 요청 부하를 분산 하지 못할 수 있습니다. 다른 극단적인 경우 파티션당 하나의 엔터티를 저장할 수 있습니다. 이를 통해 확장성이 뛰어나고 테이블 저장소에서 요청 부하를 분산할 수 있지만 엔터티 그룹 트랜잭션을 사용할 수 없습니다.  

이상적인 `PartitionKey`를 사용 하면 효율적인 쿼리를 사용할 수 있으며 솔루션을 확장할 수 있도록 충분 한 파티션이 있습니다. 일반적으로 엔터티는 충분 한 파티션에 엔터티를 분산 하는 적절 한 속성을 갖게 됩니다.

> [!NOTE]
> 예를 들어 사용자 또는 직원에 대한 정보를 저장 하는 시스템에서 `UserID` 좋은 `PartitionKey`수 있습니다. 특정 `UserID`를 파티션 키로 사용 하는 엔터티가 여러 개 있을 수 있습니다. 사용자에 대한 데이터를 저장 하는 각 엔터티는 단일 파티션으로 그룹화 됩니다. 이러한 엔터티는 뛰어난 확장성을 통해 액세스할 수 있습니다.
> 
> 

엔터티를 삽입, 업데이트 및 삭제 하는 방법과 관련 된 `PartitionKey`를 선택할 때 추가로 고려해 야 할 사항이 있습니다. 자세한 내용은이 문서의 뒷부분에 나오는 [데이터 수정을 위한 디자인](#design-for-data-modification) 을 참조 하세요.  

### <a name="optimize-queries-for-table-storage"></a>테이블 저장소에 대한 쿼리 최적화
테이블 저장소는 `PartitionKey`을 사용 하 여 엔터티를 자동으로 인덱싱하고 단일 클러스터형 인덱스에 값을 `RowKey` 합니다. 이는 point 쿼리가 가장 효율적으로 사용 되는 이유입니다. 그러나 `PartitionKey`의 클러스터형 인덱스에 대한 인덱스 이외의 인덱스는 없으며 `RowKey`.

대부분의 디자인은 여러 조건을 기반으로 엔터티를 조회할 수 있어야 한다는 요구 사항을 준수해야 합니다. 예를 들어 전자 메일, 직원 ID 또는 성을 기반으로 직원 엔터티를 찾습니다. [표 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 이러한 종류의 요구 사항을 해결 합니다. 또한이 패턴은 테이블 저장소에서 보조 인덱스를 제공 하지 않는다는 사실을 해결 하는 방법을 설명 합니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에서 서로 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 파티션 또는 별도의 테이블에 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  
* [인덱스 엔터티 패턴](#index-entities-pattern): 엔터티 목록을 반환 하는 효율적인 검색을 사용할 수 있도록 인덱스 엔터티를 유지 관리 합니다.  

### <a name="sort-data-in-table-storage"></a>테이블 저장소의 데이터 정렬

테이블 저장소는 `PartitionKey` 및 `RowKey`에 따라 오름차순으로 정렬 된 쿼리 결과를 반환 합니다.

> [!NOTE]
> Azure Cosmos DB에서 Azure Table API에 의해 반환 된 쿼리 결과는 파티션 키 또는 행 키를 기준으로 정렬 되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

테이블 저장소의 키는 문자열 값입니다. 숫자 값이 올바르게 정렬 되도록 하려면 고정 길이로 변환 하 고 0으로 채움 해야 합니다. 예를 들어 `RowKey` 사용 하는 직원 ID 값이 정수 값 이면 직원 ID **123** 을 **00000123**로 변환 해야 합니다. 

많은 애플리케이션에서 서로 다른 순서로 정렬(예: 이름 또는 입사 날짜별로 직원 정렬)된 데이터를 사용할 수 있도록 요구하고 있습니다. [테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 엔터티에 대한 대체 정렬 순서를 처리 하는 방법을 설명 합니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에서 서로 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 테이블에 있는 별도의 파티션에 서로 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.
* [로그 꼬리 패턴](#log-tail-pattern): 날짜 및 시간 역순으로 정렬 되는 `RowKey` 값을 사용 하 여 가장 최근에 파티션에 추가 된 *n 개* 엔터티를 검색 합니다.  

## <a name="design-for-data-modification"></a>데이터 수정을 위한 디자인
이 섹션에서는 삽입, 업데이트 및 삭제를 최적화하기 위한 디자인 고려 사항을 중점적으로 알아봅니다. 경우에 따라 데이터 수정을 최적화 하는 디자인에 대한 쿼리를 최적화 하는 디자인 간의 장단점을 평가 해야 합니다. 이러한 평가는 관계형 데이터베이스에 대한 디자인에서 수행 하는 작업과 유사 하지만, 관계형 데이터베이스에서는 디자인 장단점을 관리 하는 기술이 다릅니다. [테이블 디자인 패턴](#table-design-patterns) 섹션에서는 테이블 저장소에 대한 몇 가지 세부적인 디자인 패턴을 설명 하 고 이러한 장단점 중 일부를 강조 표시 합니다. 실제로 엔터티를 쿼리 하는 데 최적화 된 많은 디자인은 엔터티 수정에도 잘 작동 합니다.  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>삽입, 업데이트 및 삭제 작업 성능 최적화
엔터티를 업데이트 하거나 삭제 하려면 `PartitionKey` 및 `RowKey` 값을 사용 하 여 엔터티를 식별할 수 있어야 합니다. 이러한 측면에서 엔터티 수정에 대한 `PartitionKey` 및 `RowKey` 선택은 지점 쿼리를 지원 하기 위해 선택 하는 것과 유사한 기준을 따라야 합니다. 가능 하면 효율적으로 엔터티를 식별 하려고 합니다. 업데이트 하거나 삭제 해야 하는 `PartitionKey` 및 `RowKey` 값을 검색 하기 위해 비효율적인 파티션 또는 테이블 검색을 사용 하 여 엔터티를 찾는 것이 좋습니다.  

[표 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 삽입, 업데이트 및 삭제 작업의 성능을 최적화 하는 것입니다.  

* 대량 [삭제 패턴](#high-volume-delete-pattern): 동시 삭제를 위한 모든 엔터티를 고유한 별도의 테이블에 저장 하 여 대량의 엔터티를 삭제할 수 있습니다. 테이블을 삭제 하 여 엔터티를 삭제 합니다.  
* [데이터 계열 패턴](#data-series-pattern): 전체 데이터 계열을 단일 엔터티에 저장 하 여 요청 수를 최소화 합니다.  
* [Wide entities 패턴](#wide-entities-pattern): 여러 실제 엔터티를 사용 하 여 252 개 이상의 속성을 가진 논리적 엔터티를 저장 합니다.  
* [Large entities 패턴](#large-entities-pattern): blob storage를 사용 하 여 많은 속성 값을 저장 합니다.  

### <a name="ensure-consistency-in-your-stored-entities"></a>저장된 엔터티의 일관성 유지
데이터 수정을 최적화하기 위한 키 선택에 영향을 주는 다른 주요 요소는 원자성 트랜잭션을 사용하여 일관성을 유지하는 방법입니다. EGT는 동일한 파티션에 저장된 엔터티에서만 작동합니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 일관성 관리를 처리 합니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에서 서로 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 파티션 또는 별도의 테이블에 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern): Azure 큐를 사용 하 여 파티션 경계 또는 저장소 시스템 경계에서 궁극적으로 일관 된 동작을 사용 하도록 설정 합니다.
* [인덱스 엔터티 패턴](#index-entities-pattern): 엔터티 목록을 반환 하는 효율적인 검색을 사용할 수 있도록 인덱스 엔터티를 유지 관리 합니다.  
* [비 정규화 패턴](#denormalization-pattern): 단일 지점 쿼리로 필요한 모든 데이터를 검색할 수 있도록 관련 데이터를 단일 엔터티에 함께 결합 합니다.  
* [데이터 계열 패턴](#data-series-pattern): 전체 데이터 계열을 단일 엔터티에 저장 하 여 요청 수를 최소화 합니다.  

자세한 내용은이 문서의 뒷부분에 나오는 [엔터티 그룹 트랜잭션](#entity-group-transactions) 을 참조 하세요.  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>효율적인 수정을 위한 디자인이 효율적인 쿼리에도 유용
대부분의 경우 효율적인 쿼리를 위한 디자인은 효율적인 수정으로 이어지지만 항상 특정 시나리오에 이 사항이 적용되는지 평가해야 합니다. [테이블 디자인 패턴](#table-design-patterns) 섹션의 일부 패턴은 엔터티 쿼리 및 수정 간의 장단점을 명시적으로 평가 하므로 항상 각 작업 형식의 수를 고려해 야 합니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 효율적인 쿼리를 위한 디자인과 효율적인 데이터 수정을 위한 디자인 간의 장단점을 해결 합니다.  

* [복합 키 패턴](#compound-key-pattern): 클라이언트에서 단일 지점 쿼리로 관련 데이터를 조회할 수 있도록 하려면 복합 `RowKey` 값을 사용 합니다.  
* [로그 꼬리 패턴](#log-tail-pattern): 날짜 및 시간 역순으로 정렬 되는 `RowKey` 값을 사용 하 여 가장 최근에 파티션에 추가 된 *n 개* 엔터티를 검색 합니다.  

## <a name="encrypt-table-data"></a>테이블 데이터 암호화
.NET Azure Storage 클라이언트 라이브러리는 삽입 및 바꾸기 작업을 위한 문자열 엔터티 속성의 암호화를 지원 합니다. 암호화 된 문자열은 서비스에 이진 속성으로 저장 되며 암호 해독 후 문자열로 다시 변환 됩니다.    

테이블의 경우, 암호화 정책 외에도 사용자가 암호화할 속성을 지정해야 합니다. `EncryptProperty` 특성을 지정 하거나 (`TableEntity`에서 파생 되는 POCO 엔터티에 대해) 요청 옵션에서 암호화 확인자를 지정 합니다. 암호화 해결 프로그램은 파티션 키, 행 키 및 속성 이름을 사용 하 고 해당 속성이 암호화 되어야 하는지 여부를 나타내는 부울을 반환 하는 대리자입니다. 암호화 하는 동안 클라이언트 라이브러리는이 정보를 사용 하 여 네트워크에 쓰는 동안 속성을 암호화 해야 하는지 여부를 결정 합니다. 대리자 속성은 암호화 하는 방법 논리의 가능성도 제공 합니다. 예를 들어 X 인 경우에는 속성 A를 암호화 하 고, 그렇지 않으면 A와 B 속성을 암호화 합니다. 엔터티를 읽거나 쿼리 하는 동안에는이 정보를 제공 하지 않아도 됩니다.

Merge는 현재 지원 되지 않습니다. 이전에 다른 키를 사용 하 여 속성의 하위 집합을 암호화 했을 수 있으므로 새 속성을 병합 하 고 메타 데이터를 업데이트 하면 데이터가 손실 됩니다. 병합 하려면 서비스에서 기존 엔터티를 읽거나 속성 당 새 키를 사용 하 여 추가 서비스 호출을 수행 해야 합니다. 이러한 두 가지 모두 성능상의 이유로 적합 하지 않습니다.     

테이블 데이터를 암호화 하는 방법에 대한 자세한 내용은 [클라이언트 쪽 암호화 및 Microsoft Azure Storage에 대한 Azure Key Vault](../storage/common/storage-client-side-encryption.md)를 참조 하세요.  

## <a name="model-relationships"></a>모델 관계
도메인 모델 빌드는 복잡한 시스템의 디자인에서 중요한 단계입니다. 일반적으로 모델링 프로세스를 사용 하 여 비즈니스 도메인을 이해 하 고 시스템의 디자인을 알리는 방법으로 엔터티 및 엔터티 간의 관계를 식별 합니다. 이 섹션에서는 도메인 모델에 있는 일부 공통 관계 유형을 테이블 저장소에 대한 디자인으로 변환 하는 방법에 대해 중점적으로 설명 합니다. 논리적 데이터 모델에서 실제 NoSQL 기반 데이터 모델로 매핑하는 프로세스는 관계형 데이터베이스를 설계할 때 사용 되는 프로세스와 다릅니다. 관계형 데이터베이스 디자인은 일반적으로 중복성을 최소화 하기 위해 데이터 정규화 프로세스가 최적화 된 것으로 가정 합니다. 이러한 디자인은 또한 데이터베이스의 작동 방식에 대한 구현을 추상화 하는 선언적 쿼리 기능을 가정 합니다.  

### <a name="one-to-many-relationships"></a>일대다 관계
비즈니스 도메인 개체 간의 일대다 관계는 빈번하게 발생합니다. 예를 들어 하나의 부서에 여러 직원이 있는 경우가 여기에 해당합니다. 테이블 저장소에서 일대다 관계를 구현 하는 방법에는 여러 가지가 있으며, 각 방법은 특정 시나리오와 관련이 있을 수 있는 장단점이 있습니다.  

수십 개의 부서와 직원 엔터티가 포함 된 대기업의 예를 생각해 보세요. 모든 부서에는 직원이 많고 각 직원은 하나의 특정 부서와 연결 됩니다. 한 가지 방법은 다음과 같이 별도의 부서와 직원 엔터티를 저장 하는 것입니다.  

![부서 엔터티와 employee 엔터티를 보여 주는 그래픽][1]

이 예제에서는 `PartitionKey` 값에 따라 형식 간의 암시적 일 대 다 관계를 보여 줍니다. 각 부서에는 여러 직원이 있을 수 있습니다.  

또한 이 예에서는 부서 엔터티와 해당 관련 직원 엔터티가 동일한 파티션에 있습니다. 다른 엔터티 형식에 대해 다른 파티션, 테이블 또는 저장소 계정을 사용 하도록 선택할 수 있습니다.  

다른 방법은 다음 예와 같이 데이터를 비 정규화 하 고 비 정규화 된 부서 데이터가 있는 직원 엔터티만 저장 하는 것입니다. 이 특정 시나리오에서는 부서 관리자의 세부 정보를 변경할 수 있어야 하는 요구 사항이 있는 경우에는 이러한 비 정규화 된 방법이 적합 하지 않을 수 있습니다. 이렇게 하려면 부서의 모든 직원을 업데이트 해야 합니다.  

![Employee 엔터티 그래픽][2]

자세한 내용은 이 가이드의 뒷부분에 있는 [비정규화 패턴](#denormalization-pattern) 을 참조하세요.  

다음 표에는 일 대 다 관계가 있는 직원 및 부서 엔터티를 저장 하는 각 방법의 장점과 단점을 요약 하 여 설명 합니다. 또한 다양 한 작업을 수행 해야 하는 빈도를 고려해 야 합니다. 작업이 자주 발생 하지 않는 경우 비용이 많이 드는 작업을 포함 하는 디자인을 사용할 수 있습니다.  

<table>
<tr>
<th>접근 방식</th>
<th>장점</th>
<th>단점</th>
</tr>
<tr>
<td>별도의 엔터티 유형, 동일한 파티션, 동일한 테이블</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티를 업데이트할 수 있습니다.</li>
<li>직원 엔터티를 업데이트/삽입/삭제할 때마다 부서 엔터티를 수정해야 하는 경우 EGT를 사용하여 일관성을 유지할 수 있습니다. 예를 들어 각 부서의 직원 수를 유지 관리하는 경우가 여기에 해당됩니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동의 경우 직원과 부서 엔터티를 모두 검색 해야 할 수 있습니다.</li>
<li>스토리지 작업이 동일한 파티션에서 발생합니다. 트랜잭션 볼륨이 높으면 핫스폿이 발생할 수 있습니다.</li>
<li>직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>별도의 엔터티 형식, 서로 다른 파티션, 테이블 또는 스토리지 계정</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티 또는 직원 엔터티를 업데이트할 수 있습니다.</li>
<li>트랜잭션 볼륨이 높으면이를 통해 더 많은 파티션에 부하를 분산할 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동의 경우 직원과 부서 엔터티를 모두 검색 해야 할 수 있습니다.</li>
<li>직원을 업데이트/삽입/삭제 하 고 부서를 업데이트 하는 경우 일관성을 유지할 수 없습니다. 예를 들어 부서 엔터티의 직원 수를 업데이트하는 경우가 여기에 해당합니다.</li>
<li>직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>단일 엔터티 유형으로 비정규화</td>
<td>
<ul>
<li>단일 요청으로 필요한 모든 정보를 검색할 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>부서 정보를 업데이트 해야 하는 경우 일관성을 유지 하는 데 비용이 많이 들 수 있습니다 (부서의 모든 직원을 업데이트 해야 함).</li>
</ul>
</td>
</tr>
</table>

이러한 옵션 중에서 선택 하는 방법과 장점 및 단점 중 가장 중요 한 것은 특정 응용 프로그램 시나리오에 따라 달라 집니다. 예를 들어, 부서 엔터티를 수정 하는 빈도는 얼마나 됩니까? 모든 직원 쿼리는 추가 부서별 정보를 요구 하나요? 파티션 또는 저장소 계정에 대한 확장성 한도는 얼마나 되나요?  

### <a name="one-to-one-relationships"></a>일대일 관계
도메인 모델은 엔터티 간의 일대일 관계를 포함할 수 있습니다. 테이블 저장소에서 일 대 일 관계를 구현 해야 하는 경우 두 엔터티를 모두 검색 해야 하는 경우 두 엔터티를 연결 하는 방법을 선택 해야 합니다. 이 링크는 키 값의 규칙을 기반으로 하는 암시적 이거나, `PartitionKey` 형식으로 링크를 저장 하 고 각 엔터티의 `RowKey` 값을 관련 엔터티에 저장 하 여 명시적으로 지정할 수 있습니다. 관련 엔터티를 동일한 파티션에 저장해야 하는지 여부에 대한 자세한 내용은 [일대다 관계](#one-to-many-relationships)섹션을 참조하세요.  

테이블 저장소에서 일대일 관계를 구현 하는 데 사용할 수 있는 구현 고려 사항도 있습니다.  

* 대량 엔터티 처리 (자세한 내용은 [large entities 패턴](#large-entities-pattern)참조).  
* 액세스 제어 구현. 자세한 내용은 [공유 액세스 서명을 사용 하 여 액세스 제어](#control-access-with-shared-access-signatures)를 참조 하세요.  

### <a name="join-in-the-client"></a>클라이언트에 조인
테이블 저장소에서 관계를 모델링 하는 방법은 있지만 테이블 저장소를 사용 하는 두 가지 주요 이유는 확장성과 성능입니다. 솔루션의 성능 및 확장성을 손상 시키는 여러 관계를 모델링 하는 경우 모든 데이터 관계를 테이블 디자인에 빌드해야 하는지 여부를 확인 해야 합니다. 클라이언트 응용 프로그램에서 필요한 조인을 수행할 수 있는 경우 디자인을 간소화 하 고 솔루션의 확장성과 성능을 향상 시킬 수 있습니다.  

예를 들어 자주 변경 되지 않는 데이터를 포함 하는 작은 테이블이 있는 경우이 데이터를 한 번 검색 하 여 클라이언트에 캐시할 수 있습니다. 그러면 동일한 데이터를 검색하기 위한 반복 작업을 방지할 수 있습니다. 이 가이드에서 살펴본 예제에서 소규모 조직의 부서 집합은 작고 자주 변경 되지 않을 수 있습니다. 이렇게 하면 클라이언트 응용 프로그램에서 한 번 다운로드 하 고 조회 데이터로 캐시할 수 있는 데이터에 적합 합니다.  

### <a name="inheritance-relationships"></a>상속 관계
클라이언트 응용 프로그램에서 상속 관계의 일부를 구성 하는 클래스 집합을 사용 하 여 비즈니스 엔터티를 나타내는 경우 이러한 엔터티를 테이블 저장소에 쉽게 보관할 수 있습니다. 예를 들어 클라이언트 응용 프로그램에 정의 된 다음과 같은 클래스 집합이 있을 수 있습니다. 여기서 `Person`는 추상 클래스입니다.

![상속 관계 다이어그램][3]

단일 `Person` 테이블을 사용 하 여 테이블 저장소에 있는 두 가지 구체적 클래스의 인스턴스를 유지할 수 있습니다. 다음과 같은 엔터티를 사용 합니다.  

![Customer 엔터티 및 employee 엔터티를 보여 주는 그래픽][4]

클라이언트 코드의 같은 테이블에서 여러 엔터티 형식을 사용 하는 방법에 대한 자세한 내용은이 가이드의 뒷부분에 있는 [다른 유형의 엔터티 형식 작업](#work-with-heterogeneous-entity-types) 을 참조 하세요. 이 섹션에서는 클라이언트 코드에서 엔터티 유형을 인식하는 방법에 대한 예제를 제공합니다.  

## <a name="table-design-patterns"></a>테이블 디자인 패턴
이전 섹션에서는 쿼리를 사용 하 여 엔터티 데이터를 검색 하 고 엔터티 데이터를 삽입, 업데이트 및 삭제 하기 위해 테이블 디자인을 최적화 하는 방법에 대해 알아보았습니다. 이 섹션에서는 Table storage에서 사용 하기에 적합 한 몇 가지 패턴에 대해 설명 합니다. 또한이 가이드의 앞 부분에서 발생 한 문제 및 장단점을 실제로 해결 하는 방법도 확인할 수 있습니다. 다음 다이어그램에서는 다양 한 패턴 간의 관계를 요약 합니다.  

![테이블 디자인 패턴 다이어그램][5]

패턴 맵은 패턴 (blue)과이 가이드에 설명 된 앤티 무늬 (주황) 간의 일부 관계를 강조 표시 합니다. 물론 고려할 만한 다른 많은 패턴도 있습니다. 예를 들어 테이블 저장소에 대한 주요 시나리오 중 하나는 [명령 쿼리 책임 분리](https://msdn.microsoft.com/library/azure/jj554200.aspx) 패턴에서 [구체화 된 뷰 패턴](https://msdn.microsoft.com/library/azure/dn589782.aspx) 을 사용 하는 것입니다.  

### <a name="intra-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
동일한 파티션에 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다. 복사본 간의 업데이트는 동일 하 게 유지 됩니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 `PartitionKey` 및 `RowKey` 값을 사용 하 여 엔터티를 자동으로 인덱싱합니다. 이렇게 하면 클라이언트 응용 프로그램에서 이러한 값을 사용 하 여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용 하는 경우 클라이언트 응용 프로그램은 지점 쿼리를 사용 하 여 부서 이름 및 직원 ID (`PartitionKey` 및 `RowKey` 값)를 사용 하 여 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.

![Employee 엔터티 그래픽][6]

또한 전자 메일 주소와 같은 다른 속성의 값을 기반으로 직원 엔터티를 찾으려는 경우에는 더 효율적인 파티션 검색을 사용 하 여 일치 하는 항목을 찾아야 합니다. 이는 테이블 저장소에서 보조 인덱스를 제공 하지 않기 때문입니다. 또한 `RowKey` 순서와 다른 순서로 정렬 된 직원 목록을 요청 하는 옵션은 없습니다.  

#### <a name="solution"></a>솔루션
보조 인덱스가 없는 문제를 해결 하려면 각 엔터티의 여러 복사본을 다른 `RowKey` 값을 사용 하 여 각 복사본과 함께 저장 하면 됩니다. 다음 구조를 사용 하 여 엔터티를 저장 하는 경우 전자 메일 주소 또는 직원 ID를 기준으로 직원 엔터티를 효율적으로 검색할 수 있습니다. `RowKey`, `empid_`및 `email_`에 대한 접두사 값을 사용 하 여 전자 메일 주소 또는 직원 Id의 범위를 통해 단일 직원 또는 직원 범위를 쿼리할 수 있습니다.  

![다양 한 RowKey 값을 사용 하 여 employee 엔터티를 보여 주는 그래픽][7]

다음 두 필터 조건 (직원 ID로 조회 하는 필터와 전자 메일 주소로 조회 하는 조건)은 모두 지점 쿼리를 지정 합니다.  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

직원 엔터티 범위를 쿼리하면 직원 ID 순서로 정렬 된 범위 또는 전자 메일 주소 순서로 정렬 된 범위를 지정할 수 있습니다. `RowKey`에서 적절 한 접두사를 사용 하 여 엔터티를 쿼리 합니다.  

* 판매 부서에서 000100 ~ 000199 범위의 직원 ID를 가진 직원을 모두 찾으려면 $filter = (PartitionKey eq ' Sales ') and (RowKey ge ' empid_000100 ') 및 (RowKey le ' empid_000199 ')를 사용 합니다.  
* "A" 문자로 시작 하는 전자 메일 주소를 사용 하 여 Sales 부서의 모든 직원을 찾으려면 $filter = (PartitionKey eq ' Sales ') and (RowKey ge ' email_a ') and (RowKey lt ' email_b ')를 사용 합니다.  
  
앞의 예제에 사용 된 필터 구문은 테이블 저장소 REST API에서 가져온 것입니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조 하세요.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 테이블 저장소는 비교적 저렴 하 게 사용할 수 있으므로 중복 데이터를 저장 하는 비용 오버 헤드가 중요 한 문제가 되어서는 안 됩니다. 그러나 항상 예상 된 저장소 요구 사항에 따라 디자인 비용을 평가 하 고 클라이언트 응용 프로그램에서 실행할 쿼리를 지원 하기 위해 중복 엔터티만 추가 해야 합니다.  
* 보조 인덱스 엔터티는 원래 엔터티와 동일한 파티션에 저장 되므로 개별 파티션에 대한 확장성 목표를 초과 하지 않아야 합니다.  
* EGT를 사용하여 엔터티의 두 복사본을 원자성으로 업데이트하는 방식으로 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다. 이는 엔터티의 모든 복사본을 동일한 파티션에 저장해야 함을 의미합니다. 자세한 내용은 [엔터티 그룹 트랜잭션 사용](#entity-group-transactions)을 참조 하세요.  
* `RowKey`에 사용 되는 값은 각 엔터티에 대해 고유 해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* `RowKey` (예: 직원 ID 000223)의 숫자 값을 채우면 상한 및 하 한을 기준으로 올바른 정렬과 필터링을 수행할 수 있습니다.  
* 엔터티의 모든 속성을 복제 해야 하는 것은 아닙니다. 예를 들어 `RowKey` 전자 메일 주소를 사용 하 여 엔터티를 조회 하는 쿼리에 직원의 나이가 필요 하지 않은 경우 이러한 엔터티의 구조는 다음과 같을 수 있습니다.

  ![Employee 엔터티 그래픽][8]

* 일반적으로 중복 데이터를 저장 하 고 단일 쿼리로 필요한 모든 데이터를 검색할 수 있는지 확인 하는 것이 좋습니다. 즉, 하나의 쿼리를 사용 하 여 엔터티를 찾고 다른 쿼리를 사용 하 여 필요한 데이터를 조회할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
다음 경우에 이 패턴을 사용합니다.

- 클라이언트 응용 프로그램은 다양 한 키를 사용 하 여 엔터티를 검색 해야 합니다.
- 클라이언트는 다른 정렬 순서로 엔터티를 검색 해야 합니다.
- 다양 한 고유 값을 사용 하 여 각 엔터티를 식별할 수 있습니다.

그러나 다른 `RowKey` 값을 사용 하 여 엔터티 조회를 수행할 때는 파티션 확장성 제한을 초과 하지 않도록 해야 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [파티션 내 보조 인덱스 패턴](#inter-partition-secondary-index-pattern)
* [복합 키 패턴](#compound-key-pattern)
* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
별도의 파티션 또는 별도의 테이블에 서로 다른 `RowKey` 값을 사용 하 여 각 엔터티의 여러 복사본을 저장 합니다. 이렇게 하면 다양 한 `RowKey` 값을 사용 하 여 빠르고 효율적인 조회 및 대체 정렬 순서를 사용할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 `PartitionKey` 및 `RowKey` 값을 사용 하 여 엔터티를 자동으로 인덱싱합니다. 이렇게 하면 클라이언트 응용 프로그램에서 이러한 값을 사용 하 여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용 하는 경우 클라이언트 응용 프로그램은 지점 쿼리를 사용 하 여 부서 이름 및 직원 ID (`PartitionKey` 및 `RowKey` 값)를 사용 하 여 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.  

![Employee 엔터티 그래픽][9]

전자 메일 주소와 같은 다른 속성 값으로 기반으로 직원 엔터티를 찾을 수 있도록 하려면 비효율적인 파티션 검색을 사용하여 일치하는 항목을 찾아야 합니다. 이는 테이블 저장소에서 보조 인덱스를 제공 하지 않기 때문입니다. 또한 `RowKey` 순서와 다른 순서로 정렬 된 직원 목록을 요청 하는 옵션은 없습니다.  

이러한 엔터티에 대해 많은 양의 트랜잭션을 예측 하 고 테이블 저장소 속도로 클라이언트를 제한 하는 위험을 최소화 하려고 합니다.  

#### <a name="solution"></a>솔루션
보조 인덱스가 없는 문제를 해결 하려면 각 엔터티의 여러 복사본을 다른 `PartitionKey` 및 `RowKey` 값을 사용 하는 각 복사본과 함께 저장 하면 됩니다. 다음 구조를 사용 하 여 엔터티를 저장 하는 경우 전자 메일 주소 또는 직원 ID를 기준으로 직원 엔터티를 효율적으로 검색할 수 있습니다. `PartitionKey`, `empid_`및 `email_`에 대한 접두사 값을 사용 하 여 쿼리에 사용할 인덱스를 식별할 수 있습니다.  

![주 인덱스와 보조 인덱스의 employee 엔터티를 포함 하는 employee 엔터티를 보여 주는 그래픽][10]

다음 두 필터 조건 (직원 ID로 조회 하는 필터와 전자 메일 주소로 조회 하는 조건)은 모두 지점 쿼리를 지정 합니다.  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

직원 엔터티 범위를 쿼리하면 직원 ID 순서로 정렬 된 범위 또는 전자 메일 주소 순서로 정렬 된 범위를 지정할 수 있습니다. `RowKey`에서 적절 한 접두사를 사용 하 여 엔터티를 쿼리 합니다.  

* 직원 id를 **000100** ~ **000199**범위의 직원 id로 정렬 하 여 Sales 부서의 모든 직원을 찾으려면 다음을 사용 합니다. $filter = (PartitionKey eq ' empid_Sales ') and (rowkey ge ' 000100 ') and (rowkey le ' 000199 ')  
* "A"로 시작 하는 전자 메일 주소를 사용 하 여 Sales 부서의 모든 직원을 찾으려면 전자 메일 주소 순서로 정렬 하 고, $filter = (PartitionKey eq ' email_Sales ') and (RowKey ge ' a ') and (RowKey lt ' b ')를 사용 합니다.  

앞의 예제에 사용 된 필터 구문은 테이블 저장소 REST API에서 가져온 것입니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조 하세요.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) 을 사용하여 주 인덱스 엔터티 및 보조 인덱스 엔터티를 유지 관리함으로써 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다.  
* 테이블 저장소는 비교적 저렴 하 게 사용할 수 있으므로 중복 데이터를 저장 하는 비용 오버 헤드가 중요 한 문제가 되어서는 안 됩니다. 그러나 항상 예상 되는 저장소 요구 사항에 따라 디자인 비용을 평가 하 고, 클라이언트 응용 프로그램에서 실행할 쿼리를 지원 하기 위해 중복 엔터티만 추가 합니다.  
* `RowKey`에 사용 되는 값은 각 엔터티에 대해 고유 해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* `RowKey` (예: 직원 ID 000223)의 숫자 값을 채우면 상한 및 하 한을 기준으로 올바른 정렬과 필터링을 수행할 수 있습니다.  
* 엔터티의 모든 속성을 복제 해야 하는 것은 아닙니다. 예를 들어 `RowKey` 전자 메일 주소를 사용 하 여 엔터티를 조회 하는 쿼리에 직원의 나이가 필요 하지 않은 경우 이러한 엔터티의 구조는 다음과 같을 수 있습니다.
  
  ![보조 인덱스가 있는 employee 엔터티를 보여 주는 그래픽][11]
* 일반적으로 중복 데이터를 저장 하 고 단일 쿼리로 필요한 모든 데이터를 검색할 수 있는지 확인 하는 것이 좋습니다. 즉, 보조 인덱스를 사용 하 여 엔터티를 찾고 다른 쿼리를 사용 하 여 기본 인덱스에서 필요한 데이터를 조회할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
다음 경우에 이 패턴을 사용합니다.

- 클라이언트 응용 프로그램은 다양 한 키를 사용 하 여 엔터티를 검색 해야 합니다.
- 클라이언트는 다른 정렬 순서로 엔터티를 검색 해야 합니다.
- 다양 한 고유 값을 사용 하 여 각 엔터티를 식별할 수 있습니다.

다른 `RowKey` 값을 사용 하 여 엔터티 조회를 수행할 때 파티션 확장성 제한을 초과 하지 않도록 하려면이 패턴을 사용 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern)  
* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>결과적으로 일관성 있는 트랜잭션 패턴
Azure 큐를 사용하여 파티션 경계 또는 스토리지 시스템 경계 간에 결과적으로 일관성 있는 동작을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
EGT는 동일한 파티션 키를 공유하는 여러 엔터티 간의 원자성 트랜잭션을 지원합니다. 성능 및 확장성을 위해 일관성 요구 사항이 있는 엔터티를 별도의 파티션 또는 별도의 저장소 시스템에 저장 하도록 결정할 수 있습니다. 이러한 시나리오에서는 일관성을 유지 하기 위해 사용자를 사용할 수 없습니다. 예를 들어 다음 엔터티 간에 결과적 일관성을 유지해야 하는 요구 사항이 있을 수 있습니다.  

* 동일한 테이블, 서로 다른 테이블 또는 서로 다른 스토리지 계정의 두 파티션에 저장된 엔터티  
* Blob storage에 저장 된 blob 및 Table storage에 저장 된 엔터티입니다.  
* 테이블 저장소에 저장 된 엔터티 및 파일 시스템의 파일입니다.  
* Azure Cognitive Search을 사용 하 여 인덱싱된 테이블 저장소에 저장 된 엔터티입니다.  

#### <a name="solution"></a>솔루션
Azure 큐를 사용하면 둘 이상의 파티션 또는 스토리지 시스템 간에 결과적 일관성을 유지하는 솔루션을 구현할 수 있습니다.

이러한 접근 방식을 설명 하기 위해 이전 직원 엔터티를 보관할 수 있는 요구 사항이 있다고 가정 합니다. 이전 직원 엔터티는 드물게 쿼리 되며 현재 직원을 처리 하는 모든 활동에서 제외 되어야 합니다. 이 요구 사항을 구현 하기 위해 활성 직원을 **현재** 테이블에 저장 하 고 이전 직원을 **보관** 테이블에 저장 합니다. 직원을 보관 하려면 **현재** 테이블에서 엔터티를 삭제 하 고 **Archive** 테이블에 엔터티를 추가 해야 합니다.

그러나 이러한 두 작업을 수행 하는 데는 사용자가 사용할 수 없습니다. 오류로 인해 하나의 엔터티가 두 테이블 모두에 표시되거나 아무 테이블에도 표시되지 않는 위험을 방지하려면 보관 작업이 결과적으로 일관성이 있어야 합니다. 다음 시퀀스 다이어그램에 이 작업의 단계가 요약되어 있습니다.  

![결과적 일관성을 위한 솔루션 다이어그램][12]

클라이언트는 Azure 큐에 메시지를 배치 하 여 보관 작업을 시작 합니다 (이 예제에서는 직원 #456 보관). 작업자 역할이 새 메시지에 대해 큐를 폴링합니다. 새 메시지를 찾은 경우 메시지를 읽고 숨겨진 복사본을 큐에 남겨 둡니다. 작업자 역할이 **현재** 테이블에서 엔터티의 복사본을 가져와 **보관** 테이블에 삽입한 다음 **현재** 테이블에서 원래 엔터티를 삭제합니다. 마지막으로 이전 단계에서 오류가 발생하지 않은 경우 작업자 역할이 큐에서 숨겨진 메시지를 삭제합니다.  

이 예에서 다이어그램의 4 단계는 직원을 **보관** 테이블에 삽입 합니다. Blob 저장소의 blob 또는 파일 시스템의 파일에 직원을 추가할 수 있습니다.  

#### <a name="recover-from-failures"></a>오류 복구
작업자 역할이 보관 작업을 다시 시작 해야 하는 경우 다이어그램의 4-5 단계에서 작업을 *idempotent* 하는 것이 중요 합니다. 테이블 저장소를 사용 하는 경우 4 단계에서 "삽입 또는 바꾸기" 작업을 사용 해야 합니다. 5 단계에서는 사용 중인 클라이언트 라이브러리에서 "존재 하는 경우 삭제" 작업을 사용 해야 합니다. 다른 저장소 시스템을 사용 하는 경우 적절 한 idempotent 작업을 사용 해야 합니다.  

작업자 역할이 다이어그램에서 6 단계를 완료 하지 않는 경우 시간 제한 후에 작업자 역할이 다시 처리 하도록 준비 된 큐에 메시지가 다시 나타납니다. 작업자 역할은 큐의 메시지를 읽은 횟수를 확인 하 고, 필요한 경우 별도의 큐에 전송 하 여 조사를 위해 "포이즌" 메시지로 플래그를 지정 합니다. 큐 메시지를 읽고 큐에서 제거 횟수를 확인 하는 방법에 대한 자세한 내용은 [메시지 가져오기](https://msdn.microsoft.com/library/azure/dd179474.aspx)를 참조 하세요.  

Table storage 및 Queue storage의 일부 오류는 일시적인 오류 이며 클라이언트 응용 프로그램은이를 처리 하는 데 적합 한 다시 시도 논리를 포함 해야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션은 트랜잭션 격리를 제공 하지 않습니다. 예를 들어, 작업자 역할이 다이어그램에서 4-5 단계 사이에 있는 경우 클라이언트는 **현재** 및 **보관** 테이블을 읽고 일관 되지 않은 데이터 보기를 볼 수 있습니다. 결국 데이터는 일관성 있게 유지됩니다.  
* 최종 일관성을 유지 하기 위해 4-5 단계를 idempotent 해야 합니다.  
* 여러 큐 및 작업자 역할 인스턴스를 사용하여 솔루션을 확장할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
서로 다른 파티션 또는 테이블에 있는 엔터티 간의 결과적 일관성을 보장하려는 경우에 이 패턴을 사용합니다. 이 패턴을 확장 하 여 테이블 저장소 및 Blob 저장소에서 작업에 대한 최종 일관성을 유지 하 고 데이터베이스 또는 파일 시스템과 같은 기타 비 Azure Storage 데이터 소스를 만들 수 있습니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [병합 또는 바꾸기](#merge-or-replace)  

> [!NOTE]
> 솔루션에 트랜잭션 격리가 중요 한 경우에는 테이블을 다시 디자인 하 여 사용자가 사용할 수 있도록 하는 것이 좋습니다.  
> 
> 

### <a name="index-entities-pattern"></a>인덱스 엔터티 패턴
인덱스 엔터티를 유지 관리하여 엔터티 목록을 반환하는 효율적인 검색을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 `PartitionKey` 및 `RowKey` 값을 사용 하 여 엔터티를 자동으로 인덱싱합니다. 이를 통해 클라이언트 응용 프로그램은 지점 쿼리를 사용 하 여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용 하는 경우 클라이언트 응용 프로그램은 부서 이름 및 직원 ID (`PartitionKey` 및 `RowKey`)를 사용 하 여 개별 직원 엔터티를 효율적으로 검색할 수 있습니다.  

![Employee 엔터티 그래픽][13]

또한 last name과 같은 고유 하지 않은 다른 속성의 값을 기반으로 직원 엔터티 목록을 검색할 수 있도록 하려면 더 효율적인 파티션 검색을 사용 해야 합니다. 이 검색은 인덱스를 사용 하 여 직접 조회 하는 대신 일치 항목을 찾습니다. 이는 테이블 저장소에서 보조 인덱스를 제공 하지 않기 때문입니다.  

#### <a name="solution"></a>솔루션
이전 엔터티 구조를 사용 하 여 성을 기준으로 조회를 사용 하도록 설정 하려면 직원 Id의 목록을 유지 관리 해야 합니다. Jones와 같이 특정 성을 사용 하 여 직원 엔터티를 검색 하려면 먼저 Jones가 있는 직원의 직원 Id 목록을 찾은 다음 해당 직원 엔터티를 검색 해야 합니다. 직원 Id 목록을 저장 하는 세 가지 주요 옵션은 다음과 같습니다.  

* Blob storage를 사용 합니다.  
* 직원 엔터티와 동일한 파티션에 인덱스 엔터티 만들기  
* 별도의 파티션 또는 테이블에 인덱스 엔터티 만들기  

옵션 1: Blob 저장소 사용  

고유한 모든 이름에 대한 blob을 만들고 각 blob에는 성이 있는 직원의 `PartitionKey` (부서) 및 `RowKey` (직원 ID) 값의 목록을 저장 합니다. 직원을 추가 하거나 삭제 하는 경우 관련 blob의 내용이 직원 엔터티와 일치 하는지 확인 합니다.  

옵션 2: 동일한 파티션에 인덱스 엔터티 만들기  

다음 데이터를 저장 하는 인덱스 엔터티를 사용 합니다.  

![성이 동일한 직원 Id 목록을 포함 하는 문자열을 사용 하 여 employee 엔터티를 보여 주는 그래픽][14]

`EmployeeIDs` 속성에는 `RowKey`에 저장 된 성이 있는 직원의 직원 Id 목록이 포함 됩니다.  

다음 단계는 새 직원을 추가할 때 따라야 하는 프로세스를 간략하게 설명 합니다. 이 예에서는 Sales 부서에서 ID 000152 및 last name Jones의 직원을 추가 합니다.  

1. `PartitionKey` 값 "Sales" 및 `RowKey` 값 "Jones"를 사용 하 여 인덱스 엔터티를 검색 합니다. 이 엔터티의 ETag를 2단계에서 사용하기 위해 저장합니다.  
2. 새 employee 엔터티 (`PartitionKey` 값 "Sales" 및 `RowKey` 값 "000152")를 삽입 하 고 인덱스 엔터티 (`PartitionKey` 값 "Sales" 및 `RowKey` 값 "Jones")를 업데이트 하는 엔터티 그룹 트랜잭션 (즉, 일괄 처리 작업)을 만듭니다. EmployeeIDs 필드의 목록에 새 직원 ID를 추가 하 여이를 수행 합니다. 에 대한 자세한 내용은 [엔터티 그룹 트랜잭션](#entity-group-transactions)을 참조 하세요.  
3. 낙관적 동시성 오류로 인해 장애가 발생 하는 경우 (즉, 다른 사람이 인덱스 엔터티를 수정한 경우) 1 단계에서 다시 시작 해야 합니다.  

두 번째 옵션을 사용 하는 경우 유사한 방법을 사용 하 여 직원을 삭제할 수 있습니다. 직원의 성을 변경 하는 것은 세 가지 엔터티, 즉 employee 엔터티, 이전 성에 대한 인덱스 엔터티 및 새 성에 대한 인덱스 엔터티를 업데이트 하는 것을 실행 해야 하기 때문에 다소 복잡 합니다. 낙관적 동시성을 사용 하 여 업데이트를 수행 하는 데 사용할 수 있는 ETag 값을 검색 하려면 변경을 수행 하기 전에 각 엔터티를 검색 해야 합니다.  

다음 단계는 부서에서 특정 성을 가진 모든 직원을 조회 해야 하는 경우 수행 해야 하는 프로세스를 간략하게 설명 합니다. 이 예에서는 Sales 부서에서 성이 Jones 인 모든 직원을 조회 합니다.  

1. `PartitionKey` 값 "Sales" 및 `RowKey` 값 "Jones"를 사용 하 여 인덱스 엔터티를 검색 합니다.  
2. `EmployeeIDs` 필드에서 직원 Id 목록을 구문 분석 합니다.  
3. 이러한 각 직원 (예: 전자 메일 주소)에 대한 추가 정보가 필요한 경우 "Sales" `PartitionKey` 값을 사용 하 여 각 직원 엔터티를 검색 하 고 2 단계에서 가져온 직원 목록에서 값을 `RowKey` 합니다.  

옵션 3: 별도의 파티션 또는 테이블에 인덱스 엔터티 만들기  

이 옵션의 경우 다음 데이터를 저장 하는 인덱스 엔터티를 사용 합니다.  

![성이 동일한 직원 Id 목록을 포함 하는 문자열을 사용 하 여 employee 엔터티를 보여 주는 그래픽][15]

`EmployeeIDs` 속성에는 `RowKey`에 저장 된 성이 있는 직원의 직원 Id 목록이 포함 됩니다.  

인덱스 엔터티는 직원 엔터티와 별도의 파티션에 있기 때문에 일관성을 유지 하는 데에는 일관성 없는 Ts를 사용할 수 없습니다. 인덱스 엔터티가 궁극적으로 직원 엔터티와 일치 하는지 확인 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션을 사용 하려면 일치 하는 엔터티를 검색 하는 두 개 이상의 쿼리가 필요 합니다. 하나는 인덱스 엔터티를 쿼리하여 `RowKey` 값 목록을 가져온 다음 쿼리를 사용 하 여 목록에서 각 엔터티를 검색 하는 것입니다.  
* 개별 엔터티의 최대 크기는 1mb입니다. 솔루션의 옵션 2와 옵션 3은 특정 성에 대한 직원 Id 목록이 1mb를 초과 하지 않는다고 가정 합니다. 직원 Id 목록이 1mb를 초과 하는 경우 옵션 1을 사용 하 고 Blob storage에 인덱스 데이터를 저장 합니다.  
* 옵션 2를 사용 하는 경우 (예를 들어, 직원 추가 및 삭제를 처리 하 고 직원의 성을 변경) 트랜잭션 볼륨이 특정 파티션의 확장성 제한에 근접 하는지 평가 해야 합니다. 이 경우 궁극적으로 일관 된 솔루션 (옵션 1 또는 옵션 3)을 고려해 야 합니다. 이렇게 하면 큐를 사용 하 여 업데이트 요청을 처리 하 고, 인덱스 엔터티를 직원 엔터티와 별도의 파티션에 저장할 수 있습니다.  
* 이 솔루션의 옵션 2에서는 부서 내에서 성을 조회 하려고 한다고 가정 합니다. 예를 들어 Sales 부서에서 성이 Jones 인 직원 목록을 검색 하려고 합니다. 전체 조직에서 성이 Jones 인 모든 직원을 조회할 수 있도록 하려면 옵션 1 또는 옵션 3을 사용 합니다.
* 최종 일관성을 제공 하는 큐 기반 솔루션을 구현할 수 있습니다. 자세한 내용은 궁극적으로 일관성 있는 [트랜잭션 패턴](#eventually-consistent-transactions-pattern)을 참조 하세요.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
성이 Jones 인 모든 직원과 같이 공통 속성 값을 공유 하는 엔터티 집합을 조회 하려는 경우이 패턴을 사용 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>비정규화 패턴
관련 데이터를 단일 엔터티에 함께 통합하여 단일 지점 쿼리로 필요한 모든 데이터를 검색할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서 일반적으로 데이터를 표준화 하 여 쿼리가 여러 테이블에서 데이터를 검색할 때 발생 하는 중복을 제거 합니다. Azure 테이블의 데이터를 정규화한 경우 클라이언트와 버 간에 여러 번 왕복하여 관련 데이터를 검색해야 합니다. 예를 들어 다음 테이블 구조에서 부서에 대한 세부 정보를 검색 하려면 두 번 왕복 해야 합니다. 한 번의 이동은 관리자의 ID를 포함 하는 부서 엔터티를 인출 하 고, 두 번째 여행는 직원 엔터티에서 관리자의 세부 정보를 인출 합니다.  

![부서 엔터티 및 employee 엔터티 그래픽][16]

#### <a name="solution"></a>솔루션
두 개의 별도 엔터티에 데이터를 저장하는 대신 데이터를 비정규화하여 부서 엔터티에 관리자 세부 정보의 복사본을 유지합니다. 예:  

![비 정규화 된 부서 및 결합 된 부서 엔터티의 그래픽][17]

이러한 속성을 사용 하 여 부서 엔터티를 저장 하면 이제 지점 쿼리를 사용 하 여 부서에 대해 필요한 모든 세부 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 일부 데이터를 두 번 저장하는 것과 관련된 약간의 비용 오버헤드가 있습니다. 테이블 저장소에 대한 요청 수를 줄여 주는 성능 혜택은 일반적으로 저장소 비용이 크게 증가 하는 것 보다 큽니다. 또한이 비용은 부서 세부 정보를 가져오는 데 필요한 트랜잭션 수를 줄여 부분적으로 상쇄 됩니다.  
* 관리자에 대한 정보를 저장하는 두 엔터티의 일관성을 유지해야 합니다. 단일 원자성 트랜잭션에서 여러 엔터티를 업데이트 하기 위해 여러 엔터티를 사용 하 여 일관성 문제를 처리할 수 있습니다. 이 경우 부서 관리자의 부서 엔터티와 employee 엔터티는 동일한 파티션에 저장 됩니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
관련 정보를 자주 조회해야 하는 경우에 이 패턴을 사용합니다. 이 패턴은 클라이언트에서 필요한 데이터를 검색하기 위해 실행해야 하는 쿼리 수를 줄여 줍니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>복합 키 패턴
복합 `RowKey` 값을 사용 하 여 클라이언트에서 단일 지점 쿼리로 관련 데이터를 조회할 수 있도록 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서 쿼리에서 조인을 사용 하 여 관련 데이터를 단일 쿼리에서 클라이언트로 반환 하는 것이 자연스럽 게 사용 됩니다. 예를 들어 직원 ID를 사용하여 해당 직원에 대한 성과 및 검토 데이터가 포함된 관련 엔터티 목록을 조회할 수 있습니다.  

다음 구조를 사용 하 여 테이블 저장소에 직원 엔터티를 저장 한다고 가정 합니다.  

![Employee 엔터티 그래픽][18]

직원 들이 조직에 대해 작업 한 각 연도에 대한 검토 및 성능과 관련 된 기록 데이터를 저장 해야 하며,이 정보에는 연도별로 액세스할 수 있어야 합니다. 한 가지 옵션은 다음 구조로 엔터티를 저장하는 다른 테이블을 만드는 것입니다.  

![직원 검토 엔터티 그래픽][19]

이 방법을 사용 하면 단일 요청으로 데이터를 검색할 수 있도록 새 엔터티의 일부 정보 (예: 이름 및 성)를 복제할 수 있습니다. 그러나 두 엔터티를 원자 단위로 업데이트할 수 없으므로 강력한 일관성을 유지할 수 없습니다.  

#### <a name="solution"></a>솔루션
다음 구조의 엔터티를 사용 하 여 원래 테이블에 새 엔터티 형식을 저장 합니다.  

![복합 키가 있는 employee 엔터티 그래픽][20]

현재 `RowKey`는 직원 ID와 검토 데이터의 연도로 구성 된 복합 키입니다. 이렇게 하면 단일 엔터티에 대한 단일 요청으로 직원의 성과를 검색 하 고 데이터를 검토할 수 있습니다.  

다음 예제에서는 특정 직원(예: Sales 부서의 직원 000123)에 대한 모든 검토 데이터를 검색할 수 있는 방법을 간략하게 설명합니다.  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* `RowKey` 값을 쉽게 구문 분석할 수 있도록 적절 한 구분 문자를 사용 해야 합니다 (예: **000123_2012)** .  
* 이 엔터티는 동일한 직원의 관련 데이터가 포함 된 다른 엔터티와 동일한 파티션에 저장 됩니다. 즉, 뛰어난 Ts를 사용 하 여 강력한 일관성을 유지할 수 있습니다.
* 이 패턴이 적절 한지 여부를 확인 하기 위해 데이터를 쿼리 하는 빈도를 고려해 야 합니다. 예를 들어 자주 검토 데이터에 액세스 하 고 주 직원 데이터를 자주 액세스 하는 경우에는 별도의 엔터티로 유지 해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
자주 쿼리하는 하나 이상의 관련 엔터티를 저장해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>로그 테일 패턴
날짜 및 시간 역순으로 정렬 되는 `RowKey` 값을 사용 하 여 가장 최근에 파티션에 추가 된 *n 개* 엔터티를 검색 합니다.  

> [!NOTE]
> Azure Cosmos DB에서 Azure Table API에 의해 반환 된 쿼리 결과는 파티션 키 또는 행 키를 기준으로 정렬 되지 않습니다. 따라서이 패턴은 테이블 저장소에 적합 하지만 Azure Cosmos DB에는 적합 하지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Table Storage와 Azure Cosmos DB의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 요구 사항은 가장 최근에 생성된 엔터티(예: 직원이 제출한 가장 최근 비용 청구 10개)를 검색할 수 있는 것입니다. 테이블 쿼리는 집합에서 처음 *n* 개의 엔터티를 반환 하는 `$top` 쿼리 작업을 지원 합니다. 집합의 마지막 *n 개* 엔터티를 반환 하는 해당 쿼리 작업은 없습니다.  

#### <a name="solution"></a>솔루션
자연스럽 게 역방향 날짜/시간 순서를 정렬 하는 `RowKey`을 사용 하 여 엔터티를 저장 합니다. 따라서 가장 최근의 항목은 항상 테이블의 첫 번째 항목입니다.  

예를 들어 직원이 제출한 가장 최근 비용 청구 10개를 검색하려면 현재 날짜/시간에서 파생된 역방향 틱 값을 사용하면 됩니다. 다음 C# 코드 샘플에서는 가장 최근에서 가장 오래 된 항목으로 정렬 하는 `RowKey`에 대해 적합 한 "반전 된 틱" 값을 만드는 한 가지 방법을 보여 줍니다.  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

다음 코드를 사용 하 여 날짜/시간 값을 다시 가져올 수 있습니다.  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

테이블 쿼리는 다음과 같습니다.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 문자열 값이 예상 대로 정렬 되도록 앞에 0을 사용 하 여 역방향 틱 값을 채워야 합니다.  
* 파티션 수준의 확장성 목표를 알아야 합니다. 핫 스폿 파티션을 만들지 않도록 주의 해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
날짜/시간 역순으로 엔터티에 액세스 해야 하는 경우 또는 가장 최근에 추가 된 엔터티에 액세스 해야 하는 경우이 패턴을 사용 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [앞/뒤에 추가된 안티패턴](#prepend-append-anti-pattern)  
* [엔터티 검색](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>대용량 삭제 패턴
동시 삭제를 위한 모든 엔터티를 고유한 별도의 테이블에 저장 하 여 많은 엔터티를 삭제할 수 있습니다. 테이블을 삭제 하 여 엔터티를 삭제 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
대부분의 애플리케이션은 클라이언트 애플리케이션에서 더 이상 사용할 필요가 없거나 애플리케이션이 다른 스토리지 매체에 보관한 경우 이전 데이터를 삭제합니다. 일반적으로 날짜를 기준으로 이러한 데이터를 식별 합니다. 예를 들어 60 일이 지난 모든 로그인 요청에 대한 레코드를 삭제 해야 하는 요구 사항이 있습니다.  

한 가지 가능한 디자인은 `RowKey`로그인 요청의 날짜와 시간을 사용 하는 것입니다.  

![로그인 시도 엔터티 그래픽][21]

이 방법을 사용 하면 응용 프로그램에서 각 사용자에 대한 로그인 엔터티를 별도의 파티션에 삽입 하 고 삭제할 수 있으므로 파티션 핫스팟을 피할 수 있습니다. 그러나이 방법은 많은 엔터티가 있는 경우 비용이 많이 들고 시간이 오래 걸릴 수 있습니다. 먼저 삭제할 모든 엔터티를 식별 하기 위해 테이블 검색을 수행한 후 이전 엔터티를 모두 삭제 해야 합니다. 여러 삭제 요청을 EGT로 일괄 처리하면 이전 엔터티를 삭제하는 데 필요한 서버 왕복 횟수를 줄일 수 있습니다.  

#### <a name="solution"></a>솔루션
각 로그인 시도 날짜에 별도의 테이블을 사용합니다. 이전 엔터티 디자인을 사용 하 여 엔터티를 삽입할 때 핫스폿을 피할 수 있습니다. 이제 오래 된 엔터티를 삭제 하면 매일 수백 및 수천 개의 개별 로그인 엔터티를 검색 하 고 삭제 하는 대신 매일 하나의 테이블을 삭제 하는 것은 간단 합니다 (단일 저장소 작업).  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 특정 엔터티를 조회 하거나 다른 데이터와 연결 하거나 집계 정보를 생성 하는 등 응용 프로그램이 데이터를 사용 하는 다른 방법을 디자인에서 지원 하나요?  
* 디자인이 새 엔터티를 삽입할 때 핫스폿을 방지하나요?  
* 테이블을 삭제한 후 동일한 테이블 이름을 다시 사용하려는 경우 지연이 발생할 수 있습니다. 항상 고유한 테이블 이름을 사용하는 것이 좋습니다.  
* 새 테이블을 처음 사용할 때에는 약간의 제한이 있으며, 테이블 저장소는 액세스 패턴을 학습 하 고 노드 간에 파티션을 배포 합니다. 새 테이블을 만들어야 하는 빈도를 고려해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
동시에 삭제해야 하는 엔터티가 많은 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [엔터티 수정](#modify-entities)  

### <a name="data-series-pattern"></a>데이터 계열 패턴
전체 데이터 계열을 단일 엔터티에 저장하여 요청 수를 최소화합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 시나리오에서 애플리케이션은 보통 모든 엔터티를 동시에 검색하는 데 필요한 데이터 계열을 저장합니다. 예를 들어 애플리케이션은 각 직원이 매시간 보내는 IM 메시지 수를 기록한 다음, 이 정보를 사용하여 각 사용자가 이전 24시간 동안 보낸 메시지 수를 표시할 수 있습니다. 한 가지 디자인은 각 직원에 대한 24개의 엔터티를 저장하는 것입니다.  

![메시지 통계 엔터티 그래픽][22]

이 디자인을 사용하면 애플리케이션이 메시지 수 값을 업데이트해야 할 때마다 각 직원에 대한 엔터티를 쉽게 찾아서 업데이트할 수 있습니다. 그러나 이전 24시간 동안의 활동에 대한 차트를 그리기 위해 정보를 검색하려면 24개의 엔터티를 검색해야 합니다.  

#### <a name="solution"></a>솔루션
각 시간에 대한 메시지 수를 저장 하는 별도의 속성을 사용 하 여 다음 디자인을 사용 합니다.  

![구분 된 속성이 있는 메시지 통계 엔터티를 보여 주는 그래픽][23]

이 디자인을 사용하면 병합 작업을 통해 특정 시간 동안 각 직원의 메시지 수를 업데이트할 수 있습니다. 이제 단일 엔터티에 대한 요청을 사용 하 여 차트를 그리는 데 필요한 모든 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 전체 데이터 계열이 단일 엔터티에 맞지 않는 경우 (엔터티는 최대 252 속성을 가질 수 있음) blob과 같은 대체 데이터 저장소를 사용 합니다.  
* 여러 클라이언트에서 동시에 엔터티를 업데이트 하는 경우 **ETag** 를 사용 하 여 낙관적 동시성을 구현 합니다. 클라이언트 수가 많은 경우 경합이 크게 발생할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
개별 엔터티와 연관된 데이터 계열을 업데이트하고 검색해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [큰 엔터티 패턴](#large-entities-pattern)  
* [병합 또는 바꾸기](#merge-or-replace)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) (데이터 계열을 blob에 저장 하는 경우)  

### <a name="wide-entities-pattern"></a>넓은 엔터티 패턴
여러 실제 엔터티를 사용하여 속성이 252개가 넘는 논리적 엔터티를 저장합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티는 필수 시스템 속성을 제외 하 고 252 개의 속성을 가질 수 없으며, 총 1mb의 데이터를 저장할 수 없습니다. 관계형 데이터베이스에서 일반적으로 새 테이블을 추가 하 고 두 테이블 간에 일대일 관계를 적용 하 여 행 크기에 대한 제한을 해결할 수 있습니다.  

#### <a name="solution"></a>솔루션
테이블 저장소를 사용 하 여 여러 엔터티를 저장 하 여 252 개 이상의 속성이 포함 된 단일 대기업 개체를 나타낼 수 있습니다. 예를 들어 지난 365 일간 각 직원이 보낸 IM 메시지 수를 저장 하려는 경우 스키마가 서로 다른 두 엔터티를 사용 하는 다음 디자인을 사용할 수 있습니다.  

![Rowkey가 01 인 메시지 통계 엔터티 및 Rowkey 02가 있는 메시지 통계 엔터티를 보여 주는 그래픽][24]

서로 동기화된 상태로 유지하기 위해 두 엔터티를 모두 업데이트해야 하는 변경 내용을 적용하려는 경우 EGT를 사용할 수 있습니다. 그렇지 않으면 단일 병합 작업을 사용하여 특정 날짜의 메시지 수를 업데이트할 수 있습니다. 개별 직원에 대한 모든 데이터를 검색 하려면 두 엔터티를 모두 검색 해야 합니다. `PartitionKey` 및 `RowKey` 값을 모두 사용 하는 두 개의 효율적인 요청으로이 작업을 수행할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현 하는 방법을 결정할 때 다음 사항을 고려 하십시오.  

* 전체 논리적 엔터티를 검색하는 데에는 적어도 두 개의 스토리지 트랜잭션이 필요합니다. 그 중 하나는 각 실제 엔터티를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
속성의 크기나 수가 테이블 저장소의 개별 엔터티에 대한 제한을 초과 하는 엔터티를 저장 해야 하는 경우이 패턴을 사용 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [병합 또는 바꾸기](#merge-or-replace)

### <a name="large-entities-pattern"></a>큰 엔터티 패턴
Blob 저장소를 사용 하 여 대량 속성 값을 저장 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티는 총 1mb가 넘는 데이터를 저장할 수 없습니다. 하나 이상의 속성에서 엔터티의 총 크기가이 값을 초과 하는 값을 저장 하는 경우 테이블 저장소에 전체 엔터티를 저장할 수 없습니다.  

#### <a name="solution"></a>솔루션
하나 이상의 속성에 많은 양의 데이터가 포함 되어 있으므로 엔터티의 크기가 1mb를 초과 하는 경우 Blob 저장소에 데이터를 저장 한 다음 엔터티의 속성에 blob의 주소를 저장할 수 있습니다. 예를 들어 직원의 사진을 Blob storage에 저장 하 고 직원 엔터티의 `Photo` 속성에 사진에 대한 링크를 저장할 수 있습니다.  

![Blob 저장소를 가리키는 사진에 대한 문자열이 있는 직원 엔터티를 보여 주는 그래픽][25]

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 테이블 저장소의 엔터티와 Blob storage의 데이터 간에 최종 일관성을 유지 하려면 [궁극적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) 을 사용 하 여 엔터티를 유지 관리 합니다.
* 전체 엔터티를 검색하는 데에는 적어도 두 개의 스토리지 트랜잭션이 필요합니다. 그 중 하나는 엔터티를 검색하고, 또 하나는 Blob 데이터를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
크기가 테이블 저장소의 개별 엔터티에 대한 제한을 초과 하는 엔터티를 저장 해야 하는 경우이 패턴을 사용 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [넓은 엔터티 패턴](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>앞에 추가/뒤에 추가 안티패턴
삽입 볼륨이 많은 경우 여러 파티션에 삽입을 분산 하 여 확장성을 늘립니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
저장된 엔터티 앞 또는 뒤에 엔터티를 추가하면 일반적으로 애플리케이션에서 파티션 시퀀스의 첫 번째 또는 마지막 파티션에 새 엔터티를 추가합니다. 이 경우 특정 시간의 모든 삽입이 동일한 파티션에서 발생 하 고 핫스폿을 생성 합니다. 이를 통해 테이블 저장소는 여러 노드에 걸친 부하 분산 삽입을 방지 하며, 응용 프로그램이 파티션의 확장성 목표에 도달할 수 있습니다. 예를 들어 직원의 네트워크 및 리소스 액세스를 기록 하는 응용 프로그램의 경우를 고려해 보세요. 다음과 같은 엔터티 구조는 트랜잭션 볼륨이 개별 파티션의 확장성 목표에 도달 하는 경우 현재 시간의 파티션이 핫스폿이 될 수 있습니다.  

![Employee 엔터티 그래픽][26]

#### <a name="solution"></a>솔루션
다음 대체 엔터티 구조는 응용 프로그램이 이벤트를 기록 하므로 특정 파티션에서 핫스팟을 방지 합니다.  

![연도, 월, 일, 시간 및 이벤트 ID를 그래야만 RowKey를 사용 하 여 직원 엔터티를 보여 주는 그래픽][27]

이 예제에서는 `PartitionKey`와 `RowKey` 모두 복합 키입니다. `PartitionKey` 부서와 직원 ID를 모두 사용 하 여 여러 파티션에 걸쳐 로깅을 분산 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 삽입 시 핫 파티션 생성을 효율적으로 방지하는 대체 키 구조가 클라이언트 애플리케이션의 쿼리를 지원하나요?  
* 예상 되는 트랜잭션 볼륨은 개별 파티션에 대한 확장성 목표에 도달 하 고 테이블 저장소로 제한 될 수 있다는 것을 의미 하나요?  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
트랜잭션 볼륨의 경우에는 핫 파티션에 액세스할 때 테이블 저장소에 대한 요율 제한이 발생할 가능성이 있는 경우 앞에 추가/추가 방지 패턴을 사용 하지 마십시오.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [로그 테일 패턴](#log-tail-pattern)  
* [엔터티 수정](#modify-entities)  

### <a name="log-data-anti-pattern"></a>로그 데이터 안티패턴
일반적으로 로그 데이터를 저장 하려면 테이블 저장소 대신 Blob 저장소를 사용 해야 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
로그 데이터에 대한 일반적인 사용 사례는 특정 날짜/시간 범위에 대한 로그 항목 선택을 검색 하는 것입니다. 예를 들어 응용 프로그램이 특정 날짜에 15:04 및 15:06 사이에 기록한 모든 오류 및 중요 메시지를 찾으려고 합니다. 로그 메시지의 날짜 및 시간을 사용 하 여 로그 엔터티를 저장 하는 파티션을 결정 하지 않으려고 합니다. 이렇게 하면 특정 시간에 모든 로그 엔터티가 동일한 `PartitionKey` 값을 공유할 수 있기 때문에 핫 파티션이 생성 됩니다 ( [앞에 추가/추가 방지 패턴](#prepend-append-anti-pattern)참조). 예를 들어 로그 메시지에 대한 다음 엔터티 스키마는 응용 프로그램이 현재 날짜 및 시간에 대한 모든 로그 메시지를 파티션에 쓰도록 하므로 핫 파티션이 생성 됩니다.  

![로그 메시지 엔터티의 그래픽][28]

이 예제에서 `RowKey` 로그 메시지의 날짜 및 시간을 포함 하 여 로그 메시지가 날짜/시간 순서로 정렬 되도록 합니다. 여러 로그 메시지가 동일한 날짜 및 시간을 공유 하는 경우에도 `RowKey`는 메시지 ID를 포함 합니다.  

또 다른 방법은 응용 프로그램이 파티션 범위에서 메시지를 쓸 수 있도록 하는 `PartitionKey`를 사용 하는 것입니다. 예를 들어 로그 메시지의 원본이 여러 파티션에서 메시지를 분산 하는 방법을 제공 하는 경우 다음 엔터티 스키마를 사용할 수 있습니다.  

![로그 메시지 엔터티의 그래픽][29]

그러나이 스키마의 문제는 특정 시간 범위에 대한 모든 로그 메시지를 검색 하려면 테이블의 모든 파티션을 검색 해야 한다는 것입니다.

#### <a name="solution"></a>솔루션
이전 섹션에서는 테이블 저장소를 사용 하 여 로그 항목을 저장 하려고 시도 하는 문제를 강조 하 고 두 가지 불충분 한 디자인을 제안 했습니다. 한 솔루션은 로그 메시지를 작성 하는 데 문제가 있는 핫 파티션을 실행 합니다. 다른 솔루션은 테이블의 모든 파티션을 검색 하 여 특정 시간 범위에 대한 로그 메시지를 검색 하는 요구 사항 때문에 쿼리 성능이 저하 되었습니다. Blob storage는 이러한 유형의 시나리오에 더 나은 솔루션을 제공 하며,이는 Azure Storage 분석에서 수집 하는 로그 데이터를 저장 하는 방법입니다.  

이 섹션에서는 일반적으로 범위로 쿼리 하는 데이터를 저장 하는이 방법을 설명 하는 저장소 분석에서 로그 데이터를 Blob 저장소에 저장 하는 방법에 대해 설명 합니다.  

Storage analytics는 로그 메시지를 여러 blob에 구분 된 형식으로 저장 합니다. 구분 기호로 분리된 형식을 사용하면 클라이언트 애플리케이션에서 로그 메시지의 데이터를 쉽게 구문 분석할 수 있습니다.  

Storage analytics는 검색 중인 로그 메시지를 포함 하는 blob (또는 blob)를 찾을 수 있는 blob에 대한 명명 규칙을 사용 합니다. 예를 들어 이름이 "queue/2014/07/31/1800/000001" 인 blob에는 2014 년 7 월 31 일에 18:00부터 시작 하는 시간에 대한 큐 서비스와 관련 된 로그 메시지가 포함 되어 있습니다. "000001"은 이것이 이 기간 동안의 첫 번째 로그 파일임을 나타냅니다. 또한 Storage analytics는 파일에 저장 된 첫 번째 및 마지막 로그 메시지의 타임 스탬프를 blob 메타 데이터의 일부로 기록 합니다. Blob storage 용 API를 사용 하면 이름 접두사를 기반으로 컨테이너에서 blob을 찾을 수 있습니다. 18:00부터 시작 하는 시간 동안 큐 로그 데이터를 포함 하는 모든 blob을 찾으려면 "queue/2014/07/31/1800" 접두사를 사용할 수 있습니다.  

Storage analytics는 로그 메시지를 내부적으로 버퍼링 한 다음 적절 한 blob을 주기적으로 업데이트 하거나 로그 항목의 최신 일괄 처리를 사용 하 여 새 blob을 만듭니다. 이렇게 하면 Blob 저장소에 대해 수행 해야 하는 쓰기 수를 줄일 수 있습니다.  

응용 프로그램에서 유사한 솔루션을 구현 하는 경우 안정성과 비용 및 확장성 간의 장단점을 관리 하는 방법을 고려 합니다. 즉, 응용 프로그램에서 업데이트를 버퍼링 하 고 일괄 처리로 Blob 저장소에 쓰는 것과 비교 하 여 모든 로그 항목을 Blob 저장소에 쓰는 효과를 평가 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
로그 데이터를 저장할 방법을 결정할 때 다음 사항을 고려하세요.  

* 잠재적 핫 파티션을 방지 하는 테이블 디자인을 만드는 경우 로그 데이터에 효율적으로 액세스할 수 없다는 것을 알 수 있습니다.  
* 로그 데이터를 처리하기 위해 클라이언트에서 많은 레코드를 로드해야 하는 경우가 종종 있습니다.  
* 로그 데이터는 종종 구조화 되지만 Blob 저장소는 더 나은 솔루션 일 수 있습니다.  

### <a name="implementation-considerations"></a>구현 고려 사항
이 섹션에서는 이전 섹션에 설명된 패턴을 구현할 때 염두에 두어야 하는 몇 가지 고려 사항을 알아봅니다. 이 섹션에서는 대부분 Storage 클라이언트 라이브러리(이 문서 작성 당시 버전 4.3.0)를 사용하는 C#으로 작성된 예제를 사용합니다.  

### <a name="retrieve-entities"></a>엔터티 검색
[쿼리를 위한 디자인](#design-for-querying)섹션에 설명된 대로 가장 효율적인 쿼리는 지점 쿼리입니다. 그러나 일부 시나리오에서는 여러 엔터티를 검색 해야 할 수도 있습니다. 이 섹션에서는 저장소 클라이언트 라이브러리를 사용 하 여 엔터티를 검색 하는 몇 가지 일반적인 방법에 대해 설명 합니다.  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>저장소 클라이언트 라이브러리를 사용 하 여 지점 쿼리 실행
Point 쿼리를 실행 하는 가장 쉬운 방법은 테이블 **검색** 작업을 사용 하는 것입니다. 다음 C# 코드 조각과 같이이 작업은 값이 "Sales"이 고 값이 "212" 인 `RowKey` 엔터티를 검색 `PartitionKey` 합니다.  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

이 예제가 검색 하는 엔터티가 `EmployeeEntity`형식으로 예상 하는 방식을 확인 합니다.  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>LINQ를 사용 하 여 여러 엔터티 검색
저장소 클라이언트 라이브러리와 함께 LINQ를 사용 하 고 **where** 절이 있는 쿼리를 지정 하 여 여러 엔터티를 검색할 수 있습니다. 테이블 검색을 방지 하려면 항상 where 절에 `PartitionKey` 값을 포함 하 고 가능한 경우 테이블 및 파티션 검색을 방지 하는 `RowKey` 값을 포함 해야 합니다. 테이블 저장소는 where 절에서 사용할 수 있는 제한 된 비교 연산자 집합 (보다 큼, 보다 크거나 같음, 보다 작음, 작거나 같음, 같음 및 같지 않음)을 지원 합니다. 다음 C# 코드 조각에서는 성이 "B"로 시작 하는 모든 직원을 찾습니다 (`RowKey`에서 성을 저장 한다고 가정) (`PartitionKey` 부서 이름을 저장 한다고 가정).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

성능 향상을 위해 쿼리에서 `RowKey`와 `PartitionKey`를 모두 지정 하는 방법을 확인 합니다.  

다음 코드 샘플은 흐름 API를 사용 하 여 동일한 기능을 보여 줍니다. 일반적으로 흐름 Api에 대한 자세한 내용은 [흐름 api 디자인에 대한 모범 사례](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)를 참조 하세요.  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> 이 샘플에서는 여러 개의 `CombineFilters` 메서드를 중첩 하 여 세 개의 필터 조건을 포함 합니다.  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>쿼리에서 많은 개수의 엔터티 검색
최적의 쿼리는 `PartitionKey` 값 및 `RowKey` 값을 기준으로 개별 엔터티를 반환 합니다. 그러나 일부 시나리오에서는 동일한 파티션에서 또는 많은 파티션에서 많은 엔터티를 반환 해야 할 수도 있습니다. 이러한 시나리오에서는 항상 애플리케이션의 성능을 철저히 테스트해야 합니다.  

테이블 저장소에 대한 쿼리는 한 번에 최대 1000 개의 엔터티를 반환할 수 있으며, 최대 5 초 동안 실행할 수 있습니다. 테이블 저장소는 다음 조건 중 하나가 충족 되는 경우 클라이언트 응용 프로그램이 다음 엔터티 집합을 요청할 수 있도록 연속 토큰을 반환 합니다.

- 결과 집합에 포함 된 엔터티가 1000 개를 초과 합니다.
- 쿼리가 5 초 이내에 완료 되지 않았습니다.
- 쿼리가 파티션 경계를 교차 합니다. 

연속 토큰의 작동 방식에 대한 자세한 내용은 [쿼리 제한 시간 및 페이지 매김](https://msdn.microsoft.com/library/azure/dd135718.aspx)을 참조 하세요.  

저장소 클라이언트 라이브러리를 사용 하는 경우 테이블 저장소에서 엔터티를 반환할 때 연속 토큰을 자동으로 처리할 수 있습니다. 예를 들어 다음 C# 코드 샘플은 테이블 저장소에서이를 응답으로 반환 하는 경우 연속 토큰을 자동으로 처리 합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

다음 C# 코드는 연속 토큰을 명시적으로 처리합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

연속 토큰을 명시적으로 사용하면 애플리케이션이 데이터의 다음 세그먼트를 검색하는 시점을 제어할 수 있습니다. 예를 들어 클라이언트 응용 프로그램이 테이블에 저장 된 엔터티를 통해 페이지를 이동할 수 있는 경우 사용자는 쿼리에 의해 검색 된 모든 엔터티를 페이징 하지 않도록 결정할 수 있습니다. 응용 프로그램은 사용자가 현재 세그먼트의 모든 엔터티를 통해 페이징을 완료 한 경우에만 연속 토큰을 사용 하 여 다음 세그먼트를 검색 합니다. 이 접근 방식에는 몇 가지 이점이 있습니다.  

* 테이블 저장소에서 검색 되는 데이터의 양을 제한 하 여 네트워크를 통해 이동할 수 있습니다.  
* .NET에서 비동기 i/o를 수행할 수 있습니다.  
* 연속 토큰을 영구적 저장소로 serialize 할 수 있으므로 응용 프로그램 충돌이 발생할 경우 계속할 수 있습니다.  

> [!NOTE]
> 연속 토큰은 일반적으로 더 작은 수를 포함할 수 있지만 1000 엔터티를 포함 하는 세그먼트를 반환 합니다. 이는 조회 조건에 일치 하는 처음 n 개 엔터티를 반환 하기 위해 **Take** 를 사용 하 여 쿼리가 반환 하는 항목 수를 제한 하는 경우에도 해당 합니다. 테이블 저장소는 남은 엔터티를 검색할 수 있도록 연속 토큰과 함께 n 개 미만의 엔터티를 포함 하는 세그먼트를 반환할 수 있습니다.  
> 
> 

다음 C# 코드에서는 세그먼트 내에서 반환되는 엔터티 수를 수정하는 방법을 보여 줍니다.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>서버 쪽 프로젝션
단일 엔터티는 최대 255개의 속성을 가질 수 있으며, 크기가 최대 1MB일 수 있습니다. 테이블을 쿼리하고 엔터티를 검색 하는 경우 모든 속성이 필요 하지 않을 수 있으며, 불필요 하 게 데이터를 전송 하지 않을 수 있습니다 (대기 시간 및 비용을 줄이기 위해). 서버 쪽 프로젝션을 사용하여 필요한 속성만 전송할 수 있습니다. 다음 예에서는 쿼리에 의해 선택 된 엔터티에서 `Email` 속성 (`PartitionKey`, `RowKey`, `Timestamp`및 `ETag`함께)만 검색 합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

검색할 속성 목록에 포함 되지 않은 경우에도 `RowKey` 값을 사용할 수 있는 방법을 확인 합니다.  

### <a name="modify-entities"></a>엔터티 수정
저장소 클라이언트 라이브러리를 사용 하면 엔터티를 삽입, 삭제 및 업데이트 하 여 테이블 저장소에 저장 된 엔터티를 수정할 수 있습니다. 여러 삽입, 업데이트 및 삭제 작업을 함께 일괄 처리 하 여 필요한 왕복 횟수를 줄이고 솔루션의 성능을 향상 시킬 수 있습니다.  

저장소 클라이언트 라이브러리를 실행할 때 발생 하는 예외는 일반적으로 일괄 처리에 실패 하는 엔터티의 인덱스를 포함 합니다. 이는 EGT를 사용하는 코드를 디버그할 때 유용합니다.  

디자인이 클라이언트 애플리케이션에서 동시성 및 업데이트 작업을 처리하는 방법에 어떤 영향을 미치는지도 고려해야 합니다.  

#### <a name="managing-concurrency"></a>동시성 관리
기본적으로 테이블 저장소는 삽입, 병합 및 삭제 작업에 대한 개별 엔터티 수준에서 낙관적 동시성 검사를 구현 합니다. 단, 클라이언트는 이러한 검사를 무시 하도록 강제 설정할 수 있습니다. 자세한 내용은 [Microsoft Azure Storage에서 동시성 관리](../storage/common/storage-concurrency.md)를 참조 하세요.  

#### <a name="merge-or-replace"></a>병합 또는 바꾸기
`TableOperation` 클래스의 `Replace` 메서드는 항상 테이블 저장소의 전체 엔터티를 대체 합니다. 속성이 저장 된 엔터티에 있는 경우 요청에 속성을 포함 하지 않으면 요청은 저장 된 엔터티에서 해당 속성을 제거 합니다. 저장된 엔터티에서 속성을 명시적으로 제거하지 않은 한 모든 속성을 요청에 포함해야 합니다.  

`TableOperation` 클래스의 `Merge` 메서드를 사용 하 여 엔터티를 업데이트 하려는 경우 테이블 저장소로 보내는 데이터의 양을 줄일 수 있습니다. `Merge` 메서드는 저장 된 엔터티의 모든 속성을 요청에 포함 된 엔터티의 속성 값으로 바꿉니다. 이 메서드는 저장 된 엔터티에서 요청에 포함 되지 않은 모든 속성을 그대로 유지 합니다. 이 방법은 엔터티가 크고 요청에서 소수의 속성만 업데이트 해야 하는 경우에 유용 합니다.  

> [!NOTE]
> 엔터티가 존재 하지 않으면 `*Replace` 및 `Merge` 메서드가 실패 합니다. 또는 새 엔터티가 없는 경우 새 엔터티를 만드는 `InsertOrReplace` 및 `InsertOrMerge` 메서드를 사용할 수 있습니다.  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>유형이 다른 엔터티 유형 작업
테이블 저장소는 *스키마* 없는 테이블 저장소입니다. 즉, 단일 테이블은 여러 유형의 엔터티를 저장할 수 있으므로 디자인에 뛰어난 유연성을 제공 합니다. 다음 예제에서는 직원 및 부서 엔터티를 모두 저장하는 테이블을 보여 줍니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

각 엔터티에는 `PartitionKey`, `RowKey`및 `Timestamp` 값이 있어야 하지만 모든 속성 집합을 포함할 수 있습니다. 또한 해당 정보를 저장 하도록 선택 하지 않는 한 엔터티 유형을 나타낼 필요가 없습니다. 엔터티 유형을 식별하는 두 가지 옵션이 있습니다.  

* 엔터티 형식 앞에 `RowKey` (또는 `PartitionKey`)를 추가 합니다. 예를 들어를 `RowKey` 값으로 `EMPLOYEE_000123` 하거나 `DEPARTMENT_SALES` 합니다.  
* 다음 표와 같이 별도의 속성을 사용 하 여 엔터티 형식을 기록 합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>연령</th>
<th>이메일</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

첫 번째 옵션인 `RowKey`에 엔터티 형식을 앞에 두는 다른 형식의 두 엔터티가 동일한 키 값을 가질 수 있는 경우에 유용 합니다. 또한 이 옵션은 동일한 유형의 엔터티를 파티션에서 그룹화합니다.  

이 섹션에서 설명 하는 기술은 특히[상속 관계](#inheritance-relationships)에 대한 설명과 관련이 있습니다.  

> [!NOTE]
> 클라이언트 응용 프로그램에서 POCO 개체를 발전 시키고 다른 버전으로 작업할 수 있도록 하려면 엔터티 형식 값에 버전 번호를 포함 하는 것이 좋습니다.  
> 
> 

이 섹션의 나머지 부분에서는 동일한 테이블의 여러 엔터티 유형으로 작업하는 데 용이한 Storage 클라이언트 라이브러리의 몇 가지 기능에 대해 설명합니다.  

#### <a name="retrieve-heterogeneous-entity-types"></a>다른 유형의 엔터티 형식 검색
저장소 클라이언트 라이브러리를 사용 하는 경우 여러 엔터티 형식으로 작업 하기 위한 세 가지 옵션이 있습니다.  

특정 `RowKey` 및 `PartitionKey` 값으로 저장 된 엔터티의 형식을 알고 있는 경우 엔터티를 검색할 때 엔터티 형식을 지정할 수 있습니다. `EmployeeEntity`형식의 엔터티를 검색 하는 이전 두 예제에서는 [저장소 클라이언트 라이브러리를 사용 하 여 point 쿼리를 실행](#run-a-point-query-by-using-the-storage-client-library) 하 고 LINQ를 [사용 하 여 여러 엔터티를 검색](#retrieve-multiple-entities-by-using-linq)합니다.  

두 번째 옵션은 구체적 POCO 엔터티 형식 대신 `DynamicTableEntity` 형식 (속성 모음)을 사용 하는 것입니다. 이 옵션을 선택 하면 엔터티를 .NET 형식으로 serialize 및 deserialize 할 필요가 없기 때문에 성능이 향상 될 수도 있습니다. 다음 C# 코드는 테이블에서 다른 형식의 여러 엔터티를 검색 하지만 `DynamicTableEntity` 인스턴스로 모든 엔터티를 반환 합니다. 그런 다음 `EntityType` 속성을 사용 하 여 각 엔터티의 형식을 결정 합니다.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

다른 속성을 검색 하려면 `DynamicTableEntity` 클래스의 `Properties` 속성에서 `TryGetValue` 메서드를 사용 해야 합니다.  

세 번째 옵션은 `DynamicTableEntity` 형식과 `EntityResolver` 인스턴스를 함께 사용 하는 것입니다. 이 옵션을 사용하면 동일한 쿼리에서 여러 POCO 유형을 확인할 수 있습니다. 이 예제에서 `EntityResolver` 대리자는 `EntityType` 속성을 사용 하 여 쿼리에서 반환 하는 두 엔터티 형식을 구분 합니다. `Resolve` 메서드는 `resolver` 대리자를 사용 하 여 `DynamicTableEntity` 인스턴스를 `TableEntity` 인스턴스로 확인 합니다.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>다른 유형의 엔터티 형식 수정
삭제할 엔터티의 형식을 알 필요가 없으며, 엔터티를 삽입할 때 항상 엔터티의 형식을 알 수 있습니다. 그러나 `DynamicTableEntity` 형식을 사용 하 여 형식을 몰라도 POCO 엔터티 클래스를 사용 하지 않고 엔터티를 업데이트할 수 있습니다. 다음 코드 샘플에서는 단일 엔터티를 검색 하 고 업데이트 하기 전에 `EmployeeCount` 속성이 있는지 확인 합니다.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>공유 액세스 서명을 사용 하 여 액세스 제어
SAS (공유 액세스 서명) 토큰을 사용 하 여 테이블 저장소를 사용 하 여 직접 인증 하지 않고도 클라이언트 응용 프로그램에서 테이블 엔터티를 직접 수정 하 고 쿼리 하는 데 사용할 수 있습니다. 일반적으로 애플리케이션응에서 SAS를 사용할 경우 세 가지 주요 이점이 있습니다.  

* 저장소 계정 키를 모바일 장치와 같은 안전 하지 않은 플랫폼에 배포 하지 않아도 해당 장치에서 테이블 저장소의 엔터티에 액세스 하 고 해당 장치를 수정할 수 있습니다.  
* 웹 및 작업자 역할이 엔터티 관리에서 수행 하는 작업 중 일부를 오프 로드할 수 있습니다. 최종 사용자 컴퓨터 및 모바일 장치와 같은 클라이언트 장치로 오프 로드할 수 있습니다.  
* 특정 리소스에 대한 읽기 전용 액세스를 허용 하는 것과 같이 제한 된 사용 권한 집합을 클라이언트에 할당할 수 있습니다.  

테이블 저장소에서 SAS 토큰을 사용 하는 방법에 대한 자세한 내용은 [sas (공유 액세스 서명) 사용](../storage/common/storage-dotnet-shared-access-signature-part-1.md)을 참조 하세요.  

그러나 테이블 저장소의 엔터티에 클라이언트 응용 프로그램을 부여 하는 SAS 토큰을 여전히 생성 해야 합니다. 저장소 계정 키에 안전 하 게 액세스할 수 있는 환경에서이 작업을 수행 합니다. 일반적으로 웹 또는 작업자 역할을 사용하여 SAS 토큰을 생성하고 엔터티에 액세스해야 하는 클라이언트 애플리케이션에 이를 제공합니다. SAS 토큰을 생성하여 클라이언트에 제공하는 작업과 관련된 오버헤드가 여전히 있으므로 특히 대용량 시나리오에서 이 오버헤드를 줄일 수 있는 최상의 방법을 고려해야 합니다.  

테이블에 있는 엔터티의 하위 집합에 대한 액세스 권한을 부여 하는 SAS 토큰을 생성할 수 있습니다. 기본적으로 전체 테이블에 대한 SAS 토큰을 만듭니다. 그러나 SAS 토큰이 `PartitionKey` 값 범위 또는 `PartitionKey` 범위 및 `RowKey` 값에 대한 액세스 권한을 부여 하도록 지정할 수도 있습니다. 시스템의 개별 사용자에 대한 SAS 토큰을 생성 하도록 선택할 수 있습니다 .이 경우 각 사용자의 SAS 토큰은 테이블 저장소의 고유 엔터티에 대한 액세스만 허용 합니다.  

### <a name="asynchronous-and-parallel-operations"></a>비동기 및 병렬 작업
여러 파티션에 요청을 분산하는 경우 비동기 또는 병렬 쿼리를 사용하여 처리량 및 클라이언트 응답성을 향상시킬 수 있습니다.
예를 들어 둘 이상의 작업자 역할 인스턴스에서 테이블에 병렬로 액세스하는 경우가 있을 수 있습니다. 개별 작업자 역할은 특정 파티션 집합을 담당 하거나 단순히 여러 작업자 역할 인스턴스를 사용 하 여 테이블의 모든 파티션에 액세스할 수 있습니다.  

클라이언트 인스턴스 내에서 저장소 작업을 비동기적으로 실행 하 여 처리량을 향상 시킬 수 있습니다. Storage 클라이언트 라이브러리를 사용하면 비동기 쿼리 및 수정 사항을 쉽게 작성할 수 있습니다. 예를 들어 다음 C# 코드와 같이 파티션의 모든 엔터티를 검색 하는 동기 메서드를 사용 하 여 시작할 수 있습니다.  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

다음과 같이 쿼리가 비동기적으로 실행 되도록이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 시그니처에 `async` 한정자가 포함 되 고 `Task` 인스턴스가 반환 됩니다.  
* `ExecuteSegmented` 메서드를 호출 하 여 결과를 검색 하는 대신 메서드는 이제 `ExecuteSegmentedAsync` 메서드를 호출 합니다. 메서드는 `await` 한정자를 사용 하 여 결과를 비동기적으로 검색 합니다.  

클라이언트 응용 프로그램은 `department` 매개 변수에 대해 서로 다른 값을 사용 하 여이 메서드를 여러 번 호출할 수 있습니다. 각 쿼리는 별도의 스레드에서 실행 됩니다.  

`IEnumerable` 인터페이스가 비동기 열거형을 지원 하지 않기 때문에 `TableQuery` 클래스에 `Execute` 메서드의 비동기 버전이 없습니다.  

엔터티를 비동기식으로 삽입, 업데이트 및 삭제할 수도 있습니다. 다음 C# 예제에서는 직원 엔터티를 삽입하거나 바꾸는 간단한 동기 메서드를 보여 줍니다.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

업데이트가 다음과 같이 비동기적으로 실행 되도록이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 시그니처에 `async` 한정자가 포함 되 고 `Task` 인스턴스가 반환 됩니다.  
* `Execute` 메서드를 호출 하 여 엔터티를 업데이트 하는 대신 메서드는 이제 `ExecuteAsync` 메서드를 호출 합니다. 메서드는 `await` 한정자를 사용 하 여 결과를 비동기적으로 검색 합니다.  

클라이언트 응용 프로그램은 이와 같은 여러 비동기 메서드를 호출할 수 있으며, 각 메서드 호출은 별도의 스레드에서 실행 됩니다.  


[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

