---
title: 포함 파일
description: 포함 파일
services: virtual-machines
author: albecker1
ms.service: virtual-machines
ms.topic: include
ms.date: 10/12/2020
ms.author: albecker1
ms.custom: include file
ms.openlocfilehash: 82b4c127f983f3133326bf7fb538e40713ef9655
ms.sourcegitcommit: f28ebb95ae9aaaff3f87d8388a09b41e0b3445b5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/29/2021
ms.locfileid: "100580389"
---
![D s v 3 사양을 보여 주는 차트.](media/vm-disk-performance/dsv3-documentation.jpg)

- *캐시되지 않은* 최대 디스크 처리량은 가상 머신에서 처리할 수 있는 기본 스토리지의 최대 한도입니다.
- 호스트 캐싱을 사용하도록 설정하면 *캐시된* 최대 스토리지 처리량 한도가 별도의 한도가 됩니다.

호스트 캐싱은 데이터를 신속하게 기록하거나 읽을 수 있는 VM에 스토리지를 더 가깝게 배치하는 방식으로 작동합니다. VM에서 호스트 캐싱에 사용할 수 있는 스토리지 크기는 설명서에 나와 있습니다. 예를 들어 Standard_D8s_v3가 200GiB의 캐시 스토리지와 함께 제공되는 것을 볼 수 있습니다.

가상 머신을 만들고 디스크를 연결할 때 호스트 캐싱을 사용하도록 설정할 수 있습니다. 또한 기존 VM의 디스크에서 호스트 캐싱을 설정 및 해제할 수 있습니다.

![호스트 캐싱을 보여 주는 스크린샷.](media/vm-disk-performance/host-caching.jpg)

각 디스크에 대한 워크로드 요구 사항에 맞게 호스트 캐싱을 조정할 수 있습니다. 호스트 캐싱을 다음과 같이 설정할 수 있습니다.

- **읽기 전용**: 읽기 작업만 수행하는 워크로드
- **읽기/쓰기**: 읽기 및 쓰기 작업의 균형을 유지하는 워크로드

워크로드가 이러한 패턴 중 하나를 따르지 않는 경우 호스트 캐싱을 사용하지 않는 것이 좋습니다.

서로 다른 호스트 캐시 설정의 몇 가지 예제를 살펴보고 데이터 흐름 및 성능에 미치는 영향을 알아보겠습니다. 이 첫 번째 예제에서는 호스트 캐싱 설정이 **읽기 전용** 으로 설정된 경우 IO 요청이 어떻게 진행되는지 살펴보겠습니다.

**설정**:

- Standard_D8s_v3
  - 캐시된 IOPS: 16,000
  - 캐시되지 않은 IOPS: 12,800
- P30 데이터 디스크
  - IOPS: 5,000
  - 호스트 캐싱: **읽기 전용**

읽기를 수행할 때 캐시에 원하는 데이터가 있으면 캐시에서 요청된 데이터를 반환합니다. 디스크에서 읽을 필요가 없습니다. 이 읽기는 VM의 캐시된 제한에 합산됩니다.

![읽기 호스트 캐싱 읽기 적중을 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-read-hit.jpg)

읽기를 수행할 때 캐시에 원하는 데이터가 *없으면* 읽기 요청이 디스크로 릴레이됩니다. 그러면 디스크에서 캐시와 VM 모두에 이를 표시합니다. 이 읽기는 VM의 캐시되지 않은 제한과 VM의 캐시된 제한에 합산됩니다.

![읽기 호스트 캐싱 읽기 누락을 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-read-miss.jpg)

쓰기를 수행할 때 캐시와 디스크 모두에 디스크가 기록되어야 쓰기가 완료된 것으로 간주됩니다. 이 쓰기는 VM의 캐시되지 않은 제한과 VM의 캐시된 제한에 합산됩니다.

![읽기 호스트 캐싱 쓰기를 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-write.jpg)

다음으로, 호스트 캐시 설정이 **읽기/쓰기** 로 설정된 경우 IO 요청이 어떻게 진행되는지 살펴보겠습니다.

**설정**:

- Standard_D8s_v3
  - 캐시된 IOPS: 16,000
  - 캐시되지 않은 IOPS: 12,800
- P30 데이터 디스크
  - IOPS: 5,000
  - 호스트 캐싱: **읽기/쓰기**

읽기는 읽기 전용과 동일하게 처리됩니다. 읽기/쓰기 캐싱과 다른 것은 쓰기밖에 없습니다. 호스트 캐싱을 사용한 쓰기가 **읽기/쓰기** 로 설정된 경우, 쓰기 작업은 호스트 캐시에만 기록해야 완료된 것으로 간주됩니다. 그러면 쓰기가 백그라운드 프로세스로 디스크에 지연 기록됩니다. 즉, 쓰기가 캐시에 기록되면 캐시된 IO에 합산됩니다. 디스크에 지연 기록되면 캐시되지 않은 IO에 합산됩니다.

![읽기/쓰기 호스트 캐싱 쓰기를 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-read-write.jpg)

Standard_D8s_v3 가상 머신을 계속 살펴보겠습니다. 이번에는 디스크에서 호스트 캐싱을 사용하도록 설정하겠습니다. 또한 이제 VM의 IOPS 제한은 16,000 IOPS입니다. 각각 5,000 IOPS를 처리할 수 있는 세 개의 기본 P30 디스크가 VM에 연결되어 있습니다.

**설정**:

- Standard_D8s_v3
  - 캐시된 IOPS: 16,000
  - 캐시되지 않은 IOPS: 12,800
- P30 OS 디스크
  - IOPS: 5,000
  - 호스트 캐싱: **읽기/쓰기**
- P30 데이터 디스크 2개 × 2
  - IOPS: 5,000
  - 호스트 캐싱: **읽기/쓰기**

![호스트 캐싱 예제를 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-example-without-remote.jpg)

애플리케이션은 캐싱이 설정된 Standard_D8s_v3 가상 머신을 사용합니다. 15,000 IOPS에 대한 요청을 보냅니다. 요청은 연결된 각 기본 디스크에 5,000 IOPS로 분할됩니다. 성능 제한이 발생하지 않습니다.

## <a name="combined-uncached-and-cached-limits"></a>캐시되지 않은 제한과 캐시된 제한 결합

가상 머신의 캐시된 제한은 캐시되지 않은 제한과 별개입니다. 즉, 다른 디스크에서 호스트 캐싱을 사용하도록 설정하지 않고 VM에 연결된 디스크에서 호스트 캐싱을 사용하도록 설정할 수 있습니다. 이 구성을 통해 가상 머신은 캐시된 제한과 캐시되지 않은 제한을 더한 총 스토리지 IO를 구할 수 있습니다.

이러한 제한을 함께 사용하는 방법을 이해하는 데 도움이 되는 예제를 살펴보겠습니다. Standard_D8s_v3 가상 머신 및 프리미엄 디스크 연결 구성을 계속합니다.

**설정**:

- Standard_D8s_v3
  - 캐시된 IOPS: 16,000
  - 캐시되지 않은 IOPS: 12,800
- P30 OS 디스크
  - IOPS: 5,000
  - 호스트 캐싱: **읽기/쓰기**
- P30 데이터 디스크 2개 × 2
  - IOPS: 5,000
  - 호스트 캐싱: **읽기/쓰기**
- P30 데이터 디스크 2개 × 2
  - IOPS: 5,000
  - 호스트 캐싱: **사용 안 함**

![원격 스토리지를 사용하는 호스트 캐싱 예제를 보여 주는 다이어그램.](media/vm-disk-performance/host-caching-example-with-remote.jpg)

이 경우 Standard_D8s_v3 가상 머신에서 실행되는 애플리케이션은 25,000 IOPS를 요청합니다. 이 요청은 연결된 각 디스크에 5,000 IOPS로 분할됩니다. 세 개의 디스크가 호스트 캐싱을 사용하고, 두 개의 디스크는 호스트 캐싱을 사용하지 않습니다.

- 호스트 캐싱을 사용하는 세 개의 디스크가 16,000이라는 캐시된 제한을 넘지 않았으므로 해당 요청이 성공적으로 완료됩니다. 스토리지 성능 제한이 발생하지 않습니다.
- 호스트 캐싱을 사용하지 않는 두 개의 디스크가 12,800이라는 캐시되지 않은 제한을 넘지 않았으므로 이러한 요청도 성공적으로 완료됩니다. 제한이 발생하지 않습니다.

